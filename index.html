<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>CrossRealm • On-Chain Checkers & Chess on Core</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiQ3Jvc3NSZWalmIiwic2hvcnRfbmFtZSI6IkNSUiIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5IjoiZnVsbHNjcmVlbiIsImJhY2tncm91bmRfY29sb3IiOiIjMGYwZjBmIiwidGhlbWVfY29sb3IiOiIjZjc5MzFhIn0=">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --bitcoin-orange: #f7931a;
            --burnt-orange: #cc6600;
            --core-green: #00ff88;
            --dark-bg: #0f0f0f;
            --card-bg: #1a1a1a;
            --border: #2a2a2a;
            --text: #e0e0e0;
            --text-dim: #999;
            --success: var(--core-green);
            --error: #ff4444;
            --gradient-primary: linear-gradient(135deg, var(--bitcoin-orange), var(--burnt-orange));
            --gradient-success: linear-gradient(135deg, var(--core-green), #00cc6a);
            --wood-bg: linear-gradient(135deg, #D2B48C 0%, #8B4513 50%, #A0522D 100%);
            --wood-light: #DEB887;
            --wood-dark: #8B4513;
            --piece-black: #000;
            --piece-red: #8B0000;
            --highlight-selected: #4169E1;
            --highlight-possible: #FFD700;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            padding: 10px;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(247, 147, 26, 0.03) 2px, rgba(247, 147, 26, 0.03) 4px);
            overflow-x: hidden;
        }
        body.light-theme {
            --dark-bg: #f0f0f0;
            --card-bg: #ffffff;
            --border: #ddd;
            --text: #333;
            --text-dim: #666;
        }
        body.color-blind {
            --highlight-selected: #ff0000;
            --highlight-possible: #00ff00;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            background: var(--card-bg);
            border: 2px solid var(--bitcoin-orange);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(247, 147, 26, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }
        .logo {
            font-size: 28px;
            font-weight: bold;
            color: var(--bitcoin-orange);
            margin-bottom: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 1;
            text-align: center;
        }
        .tagline {
            color: var(--text-dim);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            position: relative;
            z-index: 1;
            text-align: center;
        }
        .wallet-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
            z-index: 1;
        }
        .wallet-status {
            font-size: 11px;
            color: var(--text-dim);
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        .wallet-address {
            color: var(--bitcoin-orange);
            font-weight: bold;
        }
        button {
            background: var(--gradient-primary);
            color: #000;
            border: none;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            min-height: 44px;
            line-height: 1.2;
            border-radius: 4px;
        }
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        button:hover::before, button:active::before {
            width: 300px;
            height: 300px;
        }
        button:hover, button:active {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px var(--core-green);
        }
        button:disabled {
            background: var(--border);
            color: var(--text-dim);
            cursor: not-allowed;
            opacity: 0.5;
        }
        button:disabled:hover, button:active:disabled {
            transform: none;
            box-shadow: none;
        }
        .disconnect-btn, .resign-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }
        .claim-btn, .claim-reward-btn, .claim-dev-btn, .claim-multi-btn, .farm-btn {
            background: var(--gradient-success);
            color: #000;
            margin-top: 10px;
        }
        .copy-btn, .share-btn {
            background: var(--gradient-success);
            color: #000;
            padding: 8px 12px;
            font-size: 12px;
            margin-left: 10px;
            min-height: 40px;
        }
        .nft-btn, .tournament-btn, .ai-btn {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            margin: 5px;
        }
        .join-btn, .move-btn {
            background: var(--gradient-success);
            color: #000;
            padding: 8px 12px;
            font-size: 12px;
            margin: 5px;
        }
        .equip-nft-btn {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            padding: 8px 12px;
            font-size: 12px;
            margin: 5px;
        }
        .farm-card {
            background: var(--card-bg);
            border: 2px solid var(--gradient-success);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            position: relative;
        }
        .farm-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: var(--gradient-success);
            border-radius: 8px;
            z-index: -1;
            opacity: 0.1;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        @media (min-width: 769px) {
            .grid {
                grid-template-columns: 350px 1fr 350px;
                gap: 20px;
            }
        }
        @media (min-width: 1201px) {
            .grid {
                grid-template-columns: 400px 1fr 400px;
                gap: 20px;
            }
        }
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .card-header {
            border-bottom: 2px solid var(--bitcoin-orange);
            padding-bottom: 12px;
            margin-bottom: 15px;
        }
        .card-title {
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--bitcoin-orange);
        }
        .tabs {
            display: flex;
            margin-bottom: 15px;
        }
        .tab-btn {
            flex: 1;
            padding: 10px;
            background: var(--border);
            color: var(--text-dim);
            border: none;
            cursor: pointer;
            border-radius: 0;
        }
        .tab-btn.active {
            background: var(--bitcoin-orange);
            color: #000;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .dev-tx-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .dev-tx-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .game-selector, .token-selector, .privacy-selector, .nft-selector {
            margin-bottom: 15px;
        }
        .game-selector select, .token-selector select, .privacy-selector select, .nft-selector select {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            width: 100%;
            border-radius: 4px;
            z-index: 10;
            appearance: menulist;
            min-height: 44px;
        }
        .game-board-container {
            position: relative;
            margin: 20px auto;
            max-width: 400px;
            background: var(--wood-bg);
            border: 10px solid #8B4513;
            border-radius: 10px;
            padding: 10px;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: var(--wood-dark);
            padding: 4px;
        }
        .board-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            border-radius: 50%;
            position: relative;
        }
        .square.light {
            background: var(--wood-light);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .square.dark {
            background: var(--wood-dark);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        .square.selected {
            background: var(--highlight-selected) !important;
            box-shadow: 0 0 10px var(--highlight-selected);
        }
        .square.possible {
            background: var(--highlight-possible) !important;
            box-shadow: 0 0 10px var(--highlight-possible);
        }
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            background: var(--piece-black);
            border: 3px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .piece.red { background: var(--piece-red); }
        .hidden { display: none; }
        .alert {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
        }
        .alert.success { background: rgba(0,255,136,0.1); color: var(--success); }
        .alert.error { background: rgba(255,68,68,0.1); color: var(--error); }
        .alert.warning { background: rgba(255,200,0,0.1); color: #ffc800; }
        .alert.info { background: rgba(100,150,255,0.1); color: #6496ff; }
        .loading { text-align: center; color: var(--text-dim); }
        .share-link-section { margin-top: 15px; }
        .share-link-section input { width: 100%; padding: 10px; background: var(--border); color: var(--text); border: 1px solid var(--bitcoin-orange); margin: 10px 0; }
        .chat-window { max-height: 200px; overflow-y: auto; background: var(--border); padding: 10px; border-radius: 4px; margin-top: 10px; }
        .chat-message { margin-bottom: 5px; font-size: 12px; }
        .game-controls { text-align: center; margin: 10px 0; }
        .leaderboard-item, .tournament-item, .game-item { padding: 10px; border: 1px solid var(--border); margin-bottom: 10px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        .rank-badge { background: var(--bitcoin-orange); color: #000; padding: 5px 10px; border-radius: 50%; font-weight: bold; }
        .tier-bar { background: var(--border); height: 10px; border-radius: 5px; overflow: hidden; margin-top: 5px; }
        .tier-progress { height: 100%; background: var(--gradient-success); transition: width 0.3s; }
        .games-list { max-height: 300px; overflow-y: auto; }
        .nft-list { max-height: 150px; overflow-y: auto; }
        .nft-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; border: 1px solid var(--border); margin-bottom: 5px; border-radius: 4px; }
        .player-indicator { display: flex; justify-content: space-around; margin: 10px 0; }
        .player-bar { background: rgba(0,0,0,0.3); height: 20px; border-radius: 10px; overflow: hidden; flex: 1; margin: 0 10px; }
        .player-progress { height: 100%; background: linear-gradient(90deg, var(--core-green), var(--bitcoin-orange)); transition: width 0.3s; }
        .settings-gear { position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 20px; cursor: pointer; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); }
        .modal-content { background: var(--card-bg); margin: 15% auto; padding: 20px; border: 1px solid var(--border); width: 80%; max-width: 400px; border-radius: 8px; }
        .close { color: var(--text); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .theme-toggle { background: var(--gradient-primary); color: #000; padding: 10px; border: none; border-radius: 4px; cursor: pointer; width: 100%; }
        .dev-panel-btn { background: var(--gradient-primary); color: #000; width: 100%; margin-top: 10px; }
        #devPanel { background: linear-gradient(135deg, var(--card-bg), rgba(247, 147, 26, 0.1)); border: 2px solid var(--bitcoin-orange); }
        .dev-chart-container { position: relative; height: 200px; margin-top: 15px; }
        .coming-soon { text-align: center; color: var(--text-dim); font-style: italic; padding: 20px; }
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 4px;
            font-family: inherit;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        @media (max-width: 768px) {
            .game-board-container { max-width: 300px; }
            .square { font-size: 24px; }
            .piece { width: 70%; height: 70%; }
            body { padding: 5px; font-size: 14px; }
            .grid { grid-template-columns: 1fr !important; }
        }
    </style>
</head>
<body>
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSettings()">&times;</span>
            <h3>Settings</h3>
            <label>Sound: <input type="checkbox" id="soundToggle" onchange="toggleSound()"></label><br>
            <label>Difficulty: <select id="difficulty" onchange="setDifficulty(this.value)" style="width: 100%; padding: 8px;"><option value="easy">Easy (Minimax)</option><option value="hard" selected>Hard (Stockfish)</option></select></label><br>
            <label>Color-Blind Mode: <input type="checkbox" id="colorBlindToggle" onchange="toggleColorBlind()"></label><br>
            <button class="theme-toggle" onclick="toggleTheme()">Toggle Theme</button>
        </div>
    </div>

    <div class="container">
        <header class="header">
            <h1 class="logo">CrossRealm</h1>
            <p class="tagline">On-Chain Checkers & Chess on Core</p>
            <div class="wallet-bar">
                <div id="walletStatus" class="wallet-status">
                    <span id="walletAddress">Not Connected</span>
                </div>
                <button id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
                <button id="disconnectBtn" class="disconnect-btn" onclick="disconnectWallet()" style="display:none;">Disconnect</button>
            </div>
        </header>
        <div id="alertArea" class="alert-area"></div>
        <div class="grid">
            <!-- Left Sidebar -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Create Game</h3>
                </div>
                <div class="game-selector">
                    <label>Game Type</label>
                    <select id="gameType" onchange="updateCreateButton()" style="width: 100%; padding: 8px;">
                        <option value="chess">Chess</option>
                        <option value="checkers">Checkers</option>
                        <option value="fighting">Fighting (Coming Soon)</option>
                        <option value="carrace">Car Race (Coming Soon)</option>
                    </select>
                </div>
                <div class="token-selector">
                    <label>Stake Token</label>
                    <select id="stakeToken" onchange="updateTokenInfo()" style="width: 100%; padding: 8px;"></select>
                </div>
                <div>
                    <label>Stake Amount</label>
                    <input type="number" id="stakeAmount" placeholder="1" step="0.01" min="0.01" onchange="updateCreateButton()">
                    <small id="stakeLimits" style="color: var(--text-dim);"></small>
                </div>
                <div class="privacy-selector">
                    <label>Privacy</label>
                    <select id="privacy" onchange="updateCreateButton()" style="width: 100%; padding: 8px;">
                        <option value="public">Public</option>
                        <option value="closed">Invite-Only</option>
                    </select>
                </div>
                <div>
                    <label>Referral (Optional)</label>
                    <input type="text" id="referral" placeholder="0x...">
                </div>
                <label><input type="checkbox" id="aiMode" onchange="toggleAI()"> Play vs AI</label>
                <label><input type="checkbox" id="zeroGasMode" onchange="updateCreateButton()"> Zero-Gas Mode (Beta)</label>
                <button id="createBtn" onclick="createGame()" disabled>Create Game</button>
                <div class="share-link-section hidden" id="shareLinkSection">
                    <label>Share Link</label>
                    <input type="text" id="shareLink" readonly>
                    <button class="copy-btn" onclick="copyShareLink()">Copy</button>
                    <button class="share-btn" onclick="shareToSocial()">Share</button>
                </div>

                <div class="card-header" style="margin-top:20px;">
                    <h3 class="card-title">Yield Farm</h3>
                </div>
                <div class="farm-card">
                    <input type="number" id="stakeFarmAmount" placeholder="Stake CORE for APY">
                    <button class="farm-btn" onclick="stakeFarm()" style="width: 100%; margin: 5px 0;">Stake</button>
                    <button class="farm-btn" onclick="claimFarm()" style="width: 100%; margin: 5px 0;">Claim Yield</button>
                    <div id="farmInfo">APY: 15% + Pot Share | Staked: 0 CORE</div>
                </div>

                <div class="card-header" style="margin-top:20px;">
                    <h3 class="card-title">Dashboard</h3>
                </div>
                <div id="dashboard">
                    <div id="tierInfo" style="font-weight:bold;margin-bottom:5px;"></div>
                    <div class="tier-bar"><div id="tierProgress" class="tier-progress"></div></div>
                    <div id="analyticsInfo">
                        <div id="winRate">Win Rate: 0%</div>
                        <div id="avgStake">Avg Stake: 0 CORE</div>
                        <div id="eloScore">ELO: 1200</div>
                    </div>
                    <div id="rewardsInfo"></div>
                    <button class="claim-btn" onclick="claimRewards()" style="width: 100%;">Claim Rewards</button>
                </div>

                <div class="card-header" style="margin-top:20px;">
                    <h3 class="card-title">NFTs</h3>
                </div>
                <div id="nftSection">
                    <div class="loading">Connect wallet to load NFTs</div>
                    <button class="equip-nft-btn" onclick="equipNFT()" disabled style="width: 100%;">Equip NFT</button>
                </div>
            </div>

            <!-- Center: Games & Board -->
            <div class="card">
                <div class="tabs">
                    <button class="tab-btn active" onclick="switchTab('pending')">Pending Games</button>
                    <button class="tab-btn" onclick="switchTab('active')">Active Game</button>
                </div>
                <div id="pendingTab" class="tab-content active">
                    <div class="games-list" id="pendingGamesList">
                        <div class="loading">Connect wallet to see games</div>
                    </div>
                    <button class="tournament-btn" onclick="loadPendingGames()" style="width: 100%; margin-top: 10px;">Refresh</button>
                </div>
                <div id="activeTab" class="tab-content">
                    <div id="gameNotLoaded" class="loading">No game loaded. Create or join one!</div>
                    <div id="gameBoard" class="hidden">
                        <div class="settings-gear" onclick="toggleSettings()">⚙️</div>
                        <div class="player-indicator">
                            <div style="flex: 1;">
                                <span style="display: block;">CPU</span>
                                <div class="player-bar"><div class="player-progress" id="cpuProgress" style="width:77%"></div></div>
                                <span id="cpuPercent">77.2%</span>
                            </div>
                            <div style="flex: 1;">
                                <span style="display: block;">Player</span>
                                <div class="player-bar"><div class="player-progress" id="playerProgress" style="width:23%"></div></div>
                                <span id="playerPercent">22.8%</span>
                            </div>
                        </div>
                        <div class="game-board-container">
                            <div class="board-labels" id="colLabels">A B C D E F G H</div>
                            <div id="board" class="game-board"></div>
                        </div>
                        <div class="game-controls">
                            <button class="move-btn" id="makeMoveBtn" onclick="makeMove()" disabled>Make Move</button>
                            <button class="resign-btn" onclick="resignGame()">Resign</button>
                            <button onclick="claimTimeout()">Claim Timeout</button>
                        </div>
                        <div style="margin-top: 10px;">
                            <input type="text" id="chatInput" placeholder="Chat (on-chain)" style="margin-bottom: 5px;">
                            <button onclick="sendChatMessage()" style="width: 100%;">Send</button>
                        </div>
                        <div id="chatWindow" class="chat-window"></div>
                    </div>
                    <div id="comingSoonBoard" class="coming-soon hidden">Coming Soon: Advanced Arcade Modes!</div>
                </div>
            </div>

            <!-- Right Sidebar -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Leaderboard</h3>
                </div>
                <div id="leaderboard">
                    <div class="loading">Loading...</div>
                </div>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Tournaments</h3>
                </div>
                <button class="tournament-btn" onclick="createTournament()" style="width: 100%;">Create Tournament</button>
                <div id="tournaments" style="margin-top: 10px;">
                    <div class="loading">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Dev Panel -->
        <div id="devPanel" class="card hidden">
            <div class="card-header">
                <h3 class="card-title">Dev Panel - Usage Analytics</h3>
            </div>
            <button class="dev-panel-btn" onclick="loadDevPanel()">Refresh Analytics</button>
            <div id="devTxList" class="dev-tx-list"></div>
            <div class="dev-chart-container">
                <canvas id="devChart"></canvas>
            </div>
            <button class="claim-dev-btn" onclick="claimDevShare()" style="width: 100%;">Claim Dev Share</button>
        </div>
    </div>

    <script>
        // ============= GLOBAL STATE - FIXED INITIALIZATION =============
        let deferredPrompt = null; // FIX: Declared at top level

        // ============= RPC ENDPOINT CONFIGURATION =============
        const RPC_ENDPOINTS = [
            'https://rpc.coredao.org',
            'https://core-rpc.vercel.app',
            'https://rpc-core.icecap.exchange',
            'https://1rpc.io/core'
        ];
        let currentRpcIndex = 0;
        async function getProvider() {
            if (typeof window.ethereum !== 'undefined') {
                return new ethers.providers.Web3Provider(window.ethereum);
            }
           
            // Fallback to public RPC if MetaMask not available
            try {
                const rpcUrl = RPC_ENDPOINTS[currentRpcIndex];
                const testProvider = new ethers.providers.JsonRpcProvider(rpcUrl, 1116);
               
                // Test the connection
                try {
                    await testProvider.getNetwork();
                    return testProvider;
                } catch (e) {
                    // Try next RPC endpoint
                    currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
                    if (currentRpcIndex !== 0) {
                        return getProvider(); // Retry with next endpoint
                    }
                    throw new Error('All RPC endpoints failed');
                }
            } catch (error) {
                console.error('RPC Provider Error:', error);
                throw error;
            }
        }
        // ============= UPDATE PROVIDER INITIALIZATION =============
        async function initializeProvider() {
            try {
                provider = await getProvider();
            } catch (error) {
                console.error('Failed to initialize provider:', error);
                showAlert('Failed to connect to blockchain. Please try again.', 'error');
            }
        }

        // Contract Addresses (UPDATED FROM DEPLOY)
        const HUB_ADDRESS = '0xAe0d46d1c3c24b5F8C183E2D410a9d1b85527Ea3';
        const REWARDS_ADDRESS = '0xb2F64c53bc21Eb1951907D8d4Dc453F648ED33B0';
        const NFT_ADDRESS = '0xBE28eCF5bbDA411721F83CEdFb97063348B47e5C';
        const STAKING_ADDRESS = '0x90B1b68621f99a1D26a20A7f7d77da444832AF20';
        const TOURNAMENT_ADDRESS = '0x0eA54a60513C6099A2b181E8e19dFAf62dD3c402'; // NEW

        const VERIFIER_ADDRESSES = {
            chess: '0x3Ae2F908b1b1E0b02D7D9b8Eeb205eefa669B9D3',
            checkers: '0xCB572c4F0a2fa1d16eC320CF0f7947Ffcaf7F5aF',
            fighting: '0x0000000000000000000000000000000000000000',
            carrace: '0x0000000000000000000000000000000000000000'
        };

        const EXPLORER_URL = 'https://scan.coredao.org/tx/';
        const baseUrl = window.location.origin + window.location.pathname;

        // ============= FIXED ABIs - REMOVED INVALID MAPPINGS =============
        const HUB_ABI = [
            "function createGame(string _gameType, uint256 _stake, address _token, bool _isPrivate, address _referral, bool _isAI, bool _zeroGas, address _verifier) external payable",
            "function joinGame(uint256 _gameId) external payable",
            "function makeMove(uint256 _gameId, string _move, string _newFen, bytes _proof) external",
            "function endGame(uint256 _gameId, bool _creatorWins) external",
            "function registerVerifier(string _gameType, address _verifier) external",
            "function settleMoveRelayer(uint256 _gameId, string _newFen) external",
            "event GameCreated(uint256 id, address creator, string gameType, uint256 stake)",
            "event GameEnded(uint256 id, address winner, uint256 eloChange)",
            "function games(uint256) view returns (uint256,string,uint256,address,address,address,bool,bool,address,bool,bool,string,address,uint256)",
            "function gameCount() view returns (uint256)"
        ];

        const REWARDS_ABI = [
            "function contributeToPot(uint256 _amount, address _token) external payable",
            "function claimRewards(address _user, uint256 _timestamp, address _token) external",
            "function getClaimableRewards(address _user, uint256 _timestamp, address _token) view returns (uint256)",
            "function getUserGamesCount(address _user) view returns (uint256)",
            "function incrementGamesPlayed(address _user) external",
            "function getUserStats(address _user) view returns (uint256 wins, uint256 losses, uint256 totalStakes, uint256 elo)",
            "event ContributionAdded(uint256 amount, address from, uint256 timestamp)",
            "event GamesPlayedIncremented(address user, uint256 count)",
            "event UserELOUpdated(address user, uint256 newElo)"
        ];

        const STAKING_ABI = [
            "function stake(uint256 _amount) external",
            "function withdraw(uint256 _amount) external",
            "function getReward() external",
            "function earned(address _account) view returns (uint256)",
            "function balances(address) view returns (uint256)"
        ];

        const NFT_ABI = [
            "function mintWinStreak(address _to) external",
            "function equip(uint256 _tokenId, string _gameType) external",
            "function balanceOf(address owner) view returns (uint256)",
            "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)"
        ];

        const ERC20_ABI = [
            "function approve(address spender, uint256 amount) external returns (bool)",
            "function transferFrom(address from, address to, uint256 amount) external returns (bool)",
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)"
        ];

        // Tokens
        const TOP_TOKENS = [
            { symbol: 'CORE', name: 'Core DAO', addr: '0x0000000000000000000000000000000000000000', decimals: 18, usdPrice: 1 },
            { symbol: 'USDC', name: 'USD Coin', addr: '0xa4151b2a3e269645181dccf2d426ce75fcbdeca9', decimals: 6, usdPrice: 1 },
            { symbol: 'USDT', name: 'Tether USD', addr: '0x900101d06a7426441ae3e9ab3b9b0f63be145f1', decimals: 6, usdPrice: 1 },
            { symbol: 'WETH', name: 'Wrapped ETH', addr: '0xeab3ac417c4d6df6b143346a46fee1b847b50296', decimals: 18, usdPrice: 3000 },
            { symbol: 'WBNB', name: 'Wrapped BNB', addr: '0xdFBc618d3c48e553Cb197F42482A0795bef7fe28', decimals: 18, usdPrice: 600 }
        ];

        const COINGECKO_IDS = {
            'CORE': 'core-dao',
            'USDC': 'usd-coin',
            'USDT': 'tether',
            'WETH': 'ethereum',
            'WBNB': 'binancecoin'
        };

        // Global State
        let provider = null;
        let signer = null;
        let userAddress = null;
        let selectedToken = 'CORE';
        let selectedGameType = 'chess';
        let currentGamePrivacy = 'public';
        let currentReferral = null;
        let aiMode = false;
        let zeroGasMode = false;
        let currentGameId = null;
        let currentGame = null;
        let chess = null;
        let checkers = null;
        let devChart = null;
        let selectedSquare = null;
        let selectedToSquare = null;
        let difficulty = 'hard';
        let userStats = { wins: 0, losses: 0, totalStakes: 0, gamesPlayed: 0, elo: 1200 };

        // ============= CHECKERS CLASS =============
        class Checkers {
            constructor(fen = null) {
                this.board = fen ? this.parseFEN(fen) : [
                    [0,1,0,1,0,1,0,1],
                    [1,0,1,0,1,0,1,0],
                    [0,1,0,1,0,1,0,1],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [-1,0,-1,0,-1,0,-1,0],
                    [0,-1,0,-1,0,-1,0,-1],
                    [-1,0,-1,0,-1,0,-1,0]
                ];
                this.turn = 1;
                this.kings = new Set();
                this.history = [];
            }
            parseFEN(fen) {
                const rows = fen.split('/');
                this.board = rows.map(row => {
                    const r = [];
                    let col = 0;
                    for (let char of row) {
                        if (isNaN(char)) {
                            r[col++] = char === 'b' ? 1 : char === 'w' ? -1 : 0;
                        } else {
                            col += parseInt(char);
                        }
                    }
                    return r;
                });
                return this.board;
            }
            toFEN() {
                return this.board.map(row => {
                    let s = '';
                    let empty = 0;
                    for (let cell of row) {
                        if (cell === 0) empty++;
                        else {
                            if (empty > 0) { s += empty; empty = 0; }
                            s += cell > 0 ? 'b' : 'w';
                        }
                    }
                    if (empty > 0) s += empty;
                    return s;
                }).join('/') + ` ${this.turn > 0 ? 'b' : 'w'}`;
            }
            getLegalMoves(square) {
                const row = Math.floor(square / 8), col = square % 8;
                const piece = this.board[row][col];
                if (!piece) return [];
                const moves = [];
                const directions = piece > 0 ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]];
                for (let [dr, dc] of directions) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && this.board[nr][nc] === 0) {
                        moves.push(nr * 8 + nc);
                    }
                }
                return moves;
            }
            move(from, to) {
                this.history.push({ board: this.board.map(r => [...r]), kings: new Set(this.kings), turn: this.turn });
                const row1 = Math.floor(from / 8), col1 = from % 8;
                const row2 = Math.floor(to / 8), col2 = to % 8;
                const piece = this.board[row1][col1];
                if (!piece || this.board[row2][col2] !== 0) return false;
                this.board[row2][col2] = piece;
                this.board[row1][col1] = 0;
                if ((piece > 0 && row2 === 7) || (piece < 0 && row2 === 0)) this.kings.add(to);
                this.turn *= -1;
                return true;
            }
            undo() {
                if (this.history.length > 0) {
                    const state = this.history.pop();
                    this.board = state.board;
                    this.kings = state.kings;
                    this.turn = state.turn;
                }
            }
            evaluate() {
                let score = 0;
                for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                    const p = this.board[r][c];
                    if (p > 0) score += 10;
                    else if (p < 0) score -= 10;
                }
                return score * this.turn;
            }
            clone() {
                const clone = new Checkers();
                clone.board = this.board.map(row => [...row]);
                clone.turn = this.turn;
                clone.kings = new Set(this.kings);
                return clone;
            }
        }

        // ============= UTILITY FUNCTIONS =============
        function showAlert(message, type = 'info') {
            const alertArea = document.getElementById('alertArea');
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            alert.innerHTML = message;
            alertArea.appendChild(alert);
            setTimeout(() => alert.remove(), 5000);
        }

        function isDev() {
            return userAddress && userAddress.toLowerCase() === '0x7adb4852c70fb86d906deb082604fc338c067135'.toLowerCase();
        }

        // ============= UPDATE CONTRACT CALLS WITH RETRY LOGIC =============
        async function executeWithRetry(fn, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (error.message.includes('too many errors') || error.message.includes('rate limit')) {
                        if (i < maxRetries - 1) {
                            currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
                            provider = await getProvider();
                            showAlert(`RPC endpoint switched. Retrying...`, 'warning');
                            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
                            continue;
                        }
                    }
                    throw error;
                }
            }
        }

        // ============= WALLET FUNCTIONS =============
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                showAlert('MetaMask not found. Please install it.', 'error');
                return;
            }
            try {
                await window.ethereum.request({ method: 'eth_requestAccounts' });
               
                // Get provider with fallback RPC
                provider = await getProvider();
                signer = provider.getSigner();
                userAddress = await signer.getAddress();
                document.getElementById('walletAddress').innerHTML = `<span class="wallet-address">${userAddress.slice(0,6)}...${userAddress.slice(-4)}</span>`;
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('disconnectBtn').style.display = 'inline-block';
                loadDashboard();
                loadUserAnalytics();
                loadTier();
                loadNFTs();
                loadPendingGames();
                loadLeaderboard();
                loadFarmInfo();
                if (isDev()) loadDevPanel();
               
                showAlert('Wallet connected!', 'success');
            } catch (error) {
                showAlert('Connection failed: ' + error.message, 'error');
                console.error('Wallet error:', error);
            }
        }

        function disconnectWallet() {
            userAddress = null;
            provider = null;
            signer = null;
            document.getElementById('walletAddress').innerHTML = 'Not Connected';
            document.getElementById('connectBtn').style.display = 'inline-block';
            document.getElementById('disconnectBtn').style.display = 'none';
            document.getElementById('createBtn').disabled = true;
            showAlert('Disconnected', 'info');
        }

        // ============= TOKEN FUNCTIONS =============
        async function fetchPrices() {
            try {
                const uniqueIds = [...new Set(Object.values(COINGECKO_IDS))].join(',');
                const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${uniqueIds}&vs_currencies=usd`);
                if (!response.ok) throw new Error('API request failed');
                const data = await response.json();
                TOP_TOKENS.forEach(token => {
                    const id = COINGECKO_IDS[token.symbol];
                    if (data[id]) token.usdPrice = data[id].usd;
                });
                updateTokenPricesDisplay();
            } catch (error) {
                console.error('Price fetch failed:', error);
            }
        }

        function updateTokenPricesDisplay() {
            const select = document.getElementById('stakeToken');
            if (!select) return;
            Array.from(select.options).forEach(option => {
                const token = TOP_TOKENS.find(t => t.symbol === option.value);
                if (token) {
                    option.textContent = `${token.symbol} (${token.name}) ~$${token.usdPrice.toFixed(2)}`;
                }
            });
        }

        function initTokenSelect() {
            const select = document.getElementById('stakeToken');
            if (!select) return;
            select.innerHTML = '';
            TOP_TOKENS.forEach(token => {
                const option = document.createElement('option');
                option.value = token.symbol;
                option.textContent = `${token.symbol} (${token.name}) ~$${token.usdPrice.toFixed(2)}`;
                select.appendChild(option);
            });
            select.value = 'CORE';
            updateTokenInfo();
        }

        function updateTokenInfo() {
            selectedToken = document.getElementById('stakeToken').value;
            const tokenInfo = TOP_TOKENS.find(t => t.symbol === selectedToken);
            const minStake = (1 / tokenInfo.usdPrice).toFixed(tokenInfo.decimals <= 6 ? tokenInfo.decimals : 8);
            const maxStake = (1000 / tokenInfo.usdPrice).toFixed(tokenInfo.decimals <= 6 ? tokenInfo.decimals : 8);
            document.getElementById('stakeLimits').textContent = `Min: ${minStake} ${selectedToken} (~$1) | Max: ${maxStake} ${selectedToken} (~$1000)`;
            updateCreateButton();
        }

        // ============= GAME CREATION =============
        function updateCreateButton() {
            const amount = parseFloat(document.getElementById('stakeAmount').value) || 0;
            const tokenInfo = TOP_TOKENS.find(t => t.symbol === selectedToken);
            const minStake = 1 / tokenInfo.usdPrice;
            document.getElementById('createBtn').disabled = !userAddress || amount < minStake;
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('gameType').addEventListener('change', (e) => {
                selectedGameType = e.target.value;
                updateCreateButton();
            });
            document.getElementById('privacy').addEventListener('change', (e) => {
                currentGamePrivacy = e.target.value;
            });
            document.getElementById('referral').addEventListener('input', (e) => {
                currentReferral = e.target.value || ethers.constants.AddressZero;
            });
        });

        function toggleAI() {
            aiMode = document.getElementById('aiMode').checked;
        }

        async function createGame() {
            if (!userAddress || !signer) {
                showAlert('Connect wallet first', 'error');
                return;
            }
            try {
                const gameType = document.getElementById('gameType').value;
                if (['fighting', 'carrace'].includes(gameType)) {
                    showAlert('Coming Soon! Stake & Beta Test.', 'info');
                    return;
                }
                const stakeAmount = parseFloat(document.getElementById('stakeAmount').value) || 0;
                const tokenInfo = TOP_TOKENS.find(t => t.symbol === selectedToken);
                const minStake = 1 / tokenInfo.usdPrice;
               
                if (stakeAmount < minStake) {
                    showAlert('Below minimum stake', 'error');
                    return;
                }
                const stake = ethers.utils.parseUnits(stakeAmount.toString(), tokenInfo.decimals);
                const verifier = VERIFIER_ADDRESSES[gameType];
                const value = selectedToken === 'CORE' ? stake : 0;
                
                // Static simulation to catch reverts
                const hubStatic = new ethers.Contract(HUB_ADDRESS, HUB_ABI, provider);
                try {
                    await hubStatic.callStatic.createGame(
                        gameType, stake, tokenInfo.addr, currentGamePrivacy === 'closed',
                        currentReferral || ethers.constants.AddressZero, aiMode, zeroGasMode, verifier,
                        { value }
                    );
                    console.log('Simulation passed');
                } catch (simError) {
                    showAlert(`Create would fail: ${simError.reason || simError.message}`, 'error');
                    console.error('Sim error:', simError);
                    return;
                }
                
                // Retry logic for contract creation
                await executeWithRetry(async () => {
                    const hub = new ethers.Contract(HUB_ADDRESS, HUB_ABI, signer);
                    // Approve token if not CORE
                    if (selectedToken !== 'CORE') {
                        const tokenContract = new ethers.Contract(tokenInfo.addr, ERC20_ABI, signer);
                        const allowance = await tokenContract.allowance(userAddress, HUB_ADDRESS);
                        if (allowance.lt(stake)) {
                            const approveTx = await tokenContract.approve(HUB_ADDRESS, stake);
                            await approveTx.wait();
                            showAlert('Token approved', 'success');
                        }
                    }
                    const tx = await hub.createGame(
                        gameType,
                        stake,
                        tokenInfo.addr,
                        currentGamePrivacy === 'closed',
                        currentReferral || ethers.constants.AddressZero,
                        aiMode,
                        zeroGasMode,
                        verifier,
                        { value, gasLimit: 300000 } // Add gas limit
                    );
                    const receipt = await tx.wait();
                    showAlert(`Game created! Tx: <a href="${EXPLORER_URL}${receipt.transactionHash}" target="_blank">${receipt.transactionHash.slice(0,10)}...</a>`, 'success');
                    document.getElementById('stakeAmount').value = '';
                    updateCreateButton();
                    loadPendingGames();
                    loadUserAnalytics();
                });
            } catch (error) {
                showAlert('Create failed: ' + error.message, 'error');
                console.error('Create error:', error);
            }
        }

        // ============= GAME LOADING =============
        async function loadPendingGames() {
            if (!userAddress) return;
            try {
                await executeWithRetry(async () => {
                    const hub = new ethers.Contract(HUB_ADDRESS, HUB_ABI, provider);
                    const count = await hub.gameCount();
                    const list = document.getElementById('pendingGamesList');
                   
                    let html = '';
                    for (let i = 1; i <= Math.min(count.toNumber(), 10); i++) {
                        const game = await hub.games(i);
                        const tokenSymbol = TOP_TOKENS.find(t => t.addr.toLowerCase() === game.token.toLowerCase())?.symbol || 'UNK';
                        html += `
                            <div class="game-item">
                                <div>${game.gameType} • Stake: ${ethers.utils.formatUnits(game.stake, 18)} ${tokenSymbol}</div>
                                <button class="join-btn" onclick="joinGame(${i})">Join</button>
                            </div>
                        `;
                    }
                   
                    list.innerHTML = html || '<p style="color: var(--text-dim);">No pending games</p>';
                });
            } catch (error) {
                console.error('Load games error:', error);
            }
        }

        async function joinGame(gameId) {
            if (!userAddress || !signer) {
                showAlert('Connect wallet first', 'error');
                return;
            }
            try {
                await executeWithRetry(async () => {
                    const hub = new ethers.Contract(HUB_ADDRESS, HUB_ABI, signer);
                    const game = await hub.games(gameId);
                    const value = game.token === ethers.constants.AddressZero ? game.stake : 0;
                    const tx = await hub.joinGame(gameId, { value, gasLimit: 300000 });
                    await tx.wait();
                    showAlert('Joined game!', 'success');
                    loadGame(gameId);
                    loadPendingGames();
                });
            } catch (error) {
                showAlert('Join failed: ' + error.message, 'error');
                console.error('Join error:', error);
            }
        }

        async function loadGame(gameId) {
            try {
                const hub = new ethers.Contract(HUB_ADDRESS, HUB_ABI, provider);
                currentGame = await hub.games(gameId);
                currentGameId = gameId;
                
                document.getElementById('gameNotLoaded').classList.add('hidden');
                document.getElementById('gameBoard').classList.remove('hidden');
                
                const initialFen = selectedGameType === 'chess' 
                    ? 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
                    : new Checkers().toFEN();
                
                renderBoard(initialFen);
                if (aiMode && currentGame.isAI) setTimeout(aiMove, 1000);
            } catch (error) {
                showAlert('Load failed: ' + error.message, 'error');
                console.error('Load error:', error);
            }
        }

        // ============= BOARD RENDERING =============
        function renderBoard(fen) {
            const board = document.getElementById('board');
            board.innerHTML = '';
            selectedSquare = null;
            selectedToSquare = null;
            document.getElementById('makeMoveBtn').disabled = true;

            if (selectedGameType === 'chess') {
                chess = new Chess(fen);
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const squareIndex = (7 - i) * 8 + j;
                        const square = document.createElement('div');
                        square.className = `square ${(i + j) % 2 ? 'light' : 'dark'}`;
                        square.setAttribute('data-index', squareIndex);
                        
                        const piece = chess.get(squareIndex);
                        if (piece) {
                            const unicode = { P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔',
                                              p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚' }[piece.type.toUpperCase() === piece.type ? piece.type.toUpperCase() : piece.type];
                            const span = document.createElement('span');
                            span.className = `piece ${piece.color === 'b' ? 'red' : ''}`;
                            span.innerHTML = unicode;
                            square.appendChild(span);
                        }
                        
                        square.onclick = (e) => selectSquare(squareIndex, e);
                        board.appendChild(square);
                    }
                }
            } else if (selectedGameType === 'checkers') {
                checkers = new Checkers(fen);
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const squareIndex = row * 8 + col;
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 ? 'dark' : 'light'}`;
                        square.setAttribute('data-index', squareIndex);
                        
                        const piece = checkers.board[row][col];
                        if (piece !== 0) {
                            const pieceEl = document.createElement('div');
                            pieceEl.className = `piece ${piece < 0 ? 'red' : ''}`;
                            square.appendChild(pieceEl);
                        }
                        
                        square.onclick = (e) => selectSquare(squareIndex, e);
                        board.appendChild(square);
                    }
                }
            }
        }

        function selectSquare(index, event) {
            document.querySelectorAll('.square').forEach(s => s.classList.remove('selected', 'possible'));
            event.target.closest('.square').classList.add('selected');
            
            if (selectedGameType === 'chess') {
                selectedSquare = index;
                const moves = chess.moves({ verbose: true, square: chess.square_name(index) });
                moves.forEach(m => {
                    const toIndex = chess.SQUARES.indexOf(m.to);
                    document.querySelector(`[data-index="${toIndex}"]`).classList.add('possible');
                });
            } else if (selectedGameType === 'checkers') {
                if (!selectedSquare) {
                    const moves = checkers.getLegalMoves(index);
                    moves.forEach(m => document.querySelector(`[data-index="${m}"]`).classList.add('possible'));
                    selectedSquare = index;
                } else {
                    selectedToSquare = index;
                    document.querySelector(`[data-index="${selectedToSquare}"]`).classList.add('possible');
                }
            }
            document.getElementById('makeMoveBtn').disabled = !selectedSquare;
        }

        async function makeMove() {
            if (!selectedSquare || !currentGameId) return;
            
            let moveStr = '', newFen = '';
            
            if (selectedGameType === 'chess' && chess && selectedSquare) {
                const moves = chess.moves({ verbose: true });
                const legalMove = moves.find(m => m.from === selectedSquare);
                if (legalMove) {
                    moveStr = legalMove.san;
                    chess.move(legalMove);
                    newFen = chess.fen();
                }
            } else if (checkers && selectedSquare && selectedToSquare) {
                if (checkers.move(selectedSquare, selectedToSquare)) {
                    moveStr = `${selectedSquare}-${selectedToSquare}`;
                    newFen = checkers.toFEN();
                    renderBoard(newFen);
                }
                selectedToSquare = null;
            }
            
            if (moveStr) {
                try {
                    const hub = new ethers.Contract(HUB_ADDRESS, HUB_ABI, signer);
                    const proof = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(newFen));
                    const tx = await hub.makeMove(currentGameId, moveStr, newFen, proof);
                    await tx.wait();
                    renderBoard(newFen);
                    showAlert('Move made!', 'success');
                    if (aiMode) setTimeout(aiMove, 500);
                } catch (error) {
                    showAlert('Move failed: ' + error.message, 'error');
                    console.error('Move error:', error);
                }
            }
        }

        async function aiMove() {
            showAlert('AI thinking...', 'info');
            
            if (selectedGameType === 'chess' && chess) {
                const moves = chess.moves({ verbose: true });
                if (moves.length > 0) {
                    const bestMove = moves[Math.floor(Math.random() * moves.length)];
                    chess.move(bestMove);
                    renderBoard(chess.fen());
                }
            } else if (checkers) {
                let bestMoves = [];
                for (let sq = 0; sq < 64; sq++) {
                    const moves = checkers.getLegalMoves(sq);
                    if (moves.length > 0) bestMoves.push({ from: sq, to: moves[0] });
                }
                if (bestMoves.length > 0) {
                    const move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                    checkers.move(move.from, move.to);
                    renderBoard(checkers.toFEN());
                }
            }
            
            showAlert('AI moved!', 'info');
        }

        function resignGame() {
            endGame(false);
        }

        async function claimTimeout() {
            endGame(true);
        }

        async function endGame(playerWins) {
            try {
                const hub = new ethers.Contract(HUB_ADDRESS, HUB_ABI, signer);
                const tx = await hub.endGame(currentGameId, playerWins);
                await tx.wait();
                
                if (playerWins) {
                    userStats.wins++;
                    showAlert('You won! Share your victory?', 'success');
                    shareToSocial(true);
                } else {
                    userStats.losses++;
                }
                
                currentGameId = null;
                document.getElementById('gameBoard').classList.add('hidden');
                document.getElementById('gameNotLoaded').classList.remove('hidden');
                loadUserAnalytics();
                loadLeaderboard();
            } catch (error) {
                showAlert('End failed: ' + error.message, 'error');
                console.error('End error:', error);
            }
        }

        // ============= CHAT =============
        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            
            const chatWindow = document.getElementById('chatWindow');
            const msg = document.createElement('div');
            msg.className = 'chat-message';
            msg.innerHTML = `<strong>You:</strong> ${message}`;
            chatWindow.appendChild(msg);
            input.value = '';
            chatWindow.scrollTop = chatWindow.scrollHeight;
            showAlert('Message sent', 'success');
        }

        // ============= DASHBOARD & ANALYTICS =============
        async function loadDashboard() {
            if (!userAddress) return;
            try {
                const rewards = new ethers.Contract(REWARDS_ADDRESS, REWARDS_ABI, provider);
                const timestamp = Math.floor(Date.now() / 1000);
                const claimable = await rewards.getClaimableRewards(userAddress, timestamp, ethers.constants.AddressZero);
                document.getElementById('rewardsInfo').innerHTML = `
                    <div><strong>Games Played:</strong> ${userStats.gamesPlayed}</div>
                    <div style="margin-top:10px;color:var(--success)"><strong>Claimable:</strong> ${ethers.utils.formatEther(claimable)} CORE</div>
                `;
            } catch (error) {
                console.error('Dashboard load error:', error);
            }
        }

        async function loadUserAnalytics() {
            if (!userAddress) return;
            try {
                const rewards = new ethers.Contract(REWARDS_ADDRESS, REWARDS_ABI, provider);
                const [wins, losses, totalStakes, elo] = await rewards.getUserStats(userAddress);
                userStats = { 
                    wins: wins.toNumber(), 
                    losses: losses.toNumber(), 
                    totalStakes: totalStakes.toNumber(), 
                    elo: elo.toNumber(),
                    gamesPlayed: wins.toNumber() + losses.toNumber()
                };
                
                const gamesPlayed = userStats.gamesPlayed;
                const winRate = gamesPlayed > 0 ? (userStats.wins / gamesPlayed * 100).toFixed(1) : 0;
                const avgStake = gamesPlayed > 0 ? (totalStakes / gamesPlayed).toFixed(4) : 0;
                
                document.getElementById('winRate').textContent = `Win Rate: ${winRate}%`;
                document.getElementById('avgStake').textContent = `Avg Stake: ${avgStake} CORE`;
                document.getElementById('eloScore').textContent = `ELO: ${elo}`;
            } catch (error) {
                console.error('Analytics load error:', error);
            }
        }

        function loadTier() {
            const games = userStats.gamesPlayed || 0;
            const tier = getTierName(games);
            document.getElementById('tierInfo').textContent = `${tier} • ${games} Games`;
            document.getElementById('tierProgress').style.width = `${Math.min((games % 10) * 10, 100)}%`;
        }

        function getTierName(games) {
            if (games >= 50) return '🏆 Legendary';
            if (games >= 25) return '💎 Diamond';
            if (games >= 10) return '🥇 Gold';
            if (games >= 5) return '🥈 Silver';
            return '⭐ Novice';
        }

        async function claimRewards() {
            if (!userAddress) return;
            try {
                const rewards = new ethers.Contract(REWARDS_ADDRESS, REWARDS_ABI, signer);
                const timestamp = Math.floor(Date.now() / 1000);
                const tx = await rewards.claimRewards(userAddress, timestamp, ethers.constants.AddressZero);
                await tx.wait();
                showAlert('Rewards claimed!', 'success');
                loadDashboard();
            } catch (error) {
                showAlert('Claim failed: ' + error.message, 'error');
                console.error('Claim error:', error);
            }
        }

        // ============= YIELD FARMING =============
        async function stakeFarm() {
            if (!userAddress) return showAlert('Connect wallet', 'error');
            
            const amount = ethers.utils.parseEther(document.getElementById('stakeFarmAmount').value || '0');
            if (amount.eq(0)) return showAlert('Enter amount', 'error');
            
            try {
                const staking = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
                const tx = await staking.stake(amount, { value: amount });
                await tx.wait();
                
                showAlert('Staked for yield!', 'success');
                document.getElementById('stakeFarmAmount').value = '';
                loadFarmInfo();
            } catch (error) {
                showAlert('Stake failed: ' + error.message, 'error');
                console.error('Stake error:', error);
            }
        }

        async function claimFarm() {
            if (!userAddress) return showAlert('Connect wallet', 'error');
            
            try {
                const staking = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
                const earned = await staking.earned(userAddress);
                
                if (earned.gt(0)) {
                    const tx = await staking.getReward();
                    await tx.wait();
                    showAlert(`Claimed ${ethers.utils.formatEther(earned)} CORE!`, 'success');
                } else {
                    showAlert('No rewards to claim', 'info');
                }
                
                loadFarmInfo();
            } catch (error) {
                showAlert('Claim failed: ' + error.message, 'error');
                console.error('Claim error:', error);
            }
        }

        async function loadFarmInfo() {
            if (!userAddress) return;
            
            try {
                const staking = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, provider);
                const balance = await staking.balances(userAddress);
                const earned = await staking.earned(userAddress);
                
                document.getElementById('farmInfo').innerHTML = 
                    `APY: 15% + Pot Share | Staked: ${ethers.utils.formatEther(balance)} CORE | Earned: ${ethers.utils.formatEther(earned)}`;
            } catch (error) {
                console.error('Farm info error:', error);
            }
        }

        // ============= NFT FUNCTIONS =============
        async function loadNFTs() {
            if (!userAddress) return;
            
            try {
                const nft = new ethers.Contract(NFT_ADDRESS, NFT_ABI, provider);
                const balance = await nft.balanceOf(userAddress);
                const nftSection = document.getElementById('nftSection');
                
                let html = '';
                for (let i = 0; i < balance.toNumber(); i++) {
                    const tokenId = await nft.tokenOfOwnerByIndex(userAddress, i);
                    html += `
                        <div class="nft-item">
                            NFT #${tokenId.toString()} 
                            <button class="equip-nft-btn" onclick="equipNFT(${tokenId})" style="padding: 4px 8px; font-size: 11px;">Equip</button>
                        </div>
                    `;
                }
                
                nftSection.innerHTML = balance.toNumber() > 0 
                    ? html 
                    : '<div style="color: var(--text-dim);">No NFTs owned</div>';
                
                const equipBtn = document.querySelector('.equip-nft-btn');
                if (equipBtn) equipBtn.disabled = balance.toNumber() === 0;
            } catch (error) {
                console.error('NFT load error:', error);
            }
        }

        async function equipNFT(tokenId) {
            if (!tokenId) return showAlert('Select NFT first', 'error');
            
            try {
                const nft = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
                const tx = await nft.equip(tokenId, selectedGameType);
                await tx.wait();
                showAlert(`NFT #${tokenId} equipped for ${selectedGameType}!`, 'success');
            } catch (error) {
                showAlert('Equip failed: ' + error.message, 'error');
                console.error('Equip error:', error);
            }
        }

        // ============= LEADERBOARD =============
        async function loadLeaderboard() {
            try {
                const mockLeaderboard = [
                    { rank: 1, name: '@ChessMaster', wins: 147, elo: 2850, medal: '🏆' },
                    { rank: 2, name: '@CheckersPro', wins: 120, elo: 2400, medal: '💎' },
                    { rank: 3, name: '@StrategyKing', wins: 98, elo: 2200, medal: '🥇' },
                    { rank: 4, name: '@GameNinja', wins: 87, elo: 2050, medal: '🥈' },
                    { rank: 5, name: '@BrainMaster', wins: 76, elo: 1950, medal: '🥉' }
                ];
                
                if (userAddress && userStats.elo > 1200) {
                    mockLeaderboard.push({
                        rank: 6,
                        name: `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`,
                        wins: userStats.wins,
                        elo: userStats.elo,
                        medal: '⭐'
                    });
                }
                
                const html = mockLeaderboard.map(player => `
                    <div class="leaderboard-item">
                        <div class="rank-badge">#${player.rank}</div>
                        <div>
                            <strong>${player.name}</strong><br>
                            <small>${player.wins} Wins • ELO ${player.elo}</small>
                        </div>
                        <div style="font-size: 20px;">${player.medal}</div>
                    </div>
                `).join('');
                
                document.getElementById('leaderboard').innerHTML = html;
            } catch (error) {
                console.error('Leaderboard load error:', error);
            }
        }

        // ============= TOURNAMENTS =============
        async function createTournament() {
            showAlert('Tournament creation coming soon!', 'info');
        }

        function loadTournaments() {
            const html = `
                <div class="tournament-item">
                    <div><strong>Core Chess Open</strong><br><small>Prize Pool: 100 CORE</small></div>
                    <button class="tournament-btn" onclick="joinTournament(1)">Join</button>
                </div>
                <div class="tournament-item">
                    <div><strong>Checkers Championship</strong><br><small>Prize Pool: 50 CORE</small></div>
                    <button class="tournament-btn" onclick="joinTournament(2)">Join</button>
                </div>
            `;
            document.getElementById('tournaments').innerHTML = html;
        }

        function joinTournament(id) {
            showAlert(`Joined tournament #${id}!`, 'success');
        }

        // ============= TAB SWITCHING =============
        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tab + 'Tab').classList.add('active');
        }

        // ============= SETTINGS & THEME =============
        function toggleSettings() {
            document.getElementById('settingsModal').style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function toggleSound() {
            showAlert('Sound toggled!', 'success');
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                oscillator.connect(audioCtx.destination);
                oscillator.frequency.value = 400;
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } catch (e) {
                console.log('Audio not available');
            }
        }

        function toggleColorBlind() {
            document.body.classList.toggle('color-blind');
            showAlert('Color-blind mode toggled!', 'success');
        }

        function setDifficulty(diff) {
            difficulty = diff;
            showAlert(`Difficulty set to ${diff}!`, 'info');
        }

        function toggleTheme() {
            document.body.classList.toggle('light-theme');
            showAlert('Theme toggled!', 'success');
        }

        // ============= SHARE FUNCTIONS =============
        function copyShareLink() {
            const link = document.getElementById('shareLink');
            link.select();
            document.execCommand('copy');
            showAlert('Link copied!', 'success');
        }

        async function shareToSocial(isWin = false) {
            const link = document.getElementById('shareLink') ? document.getElementById('shareLink').value : baseUrl;
            let title = isWin ? `I won on CrossRealm! ELO: ${userStats.elo} 🎉 Join: ` : 'Join my CrossRealm Game!';
            
            if (navigator.share) {
                try {
                    await navigator.share({ 
                        title: 'CrossRealm - On-Chain Gaming', 
                        url: link 
                    });
                } catch (e) {
                    console.log('Share cancelled');
                }
            } else {
                const tweetText = encodeURIComponent(`${title} ${link} #CrossRealm #OnChainGaming`);
                window.open(`https://twitter.com/intent/tweet?text=${tweetText}`, '_blank');
            }
        }

        // ============= DEV PANEL =============
        async function loadDevPanel() {
            if (!isDev()) return;
            
            document.getElementById('devPanel').classList.remove('hidden');
            
            try {
                const hub = new ethers.Contract(HUB_ADDRESS, HUB_ABI, provider);
                const gameCount = await hub.gameCount();
                
                let html = `<div style="color: var(--bitcoin-orange);">
                    <strong>Protocol Stats</strong><br>
                    Total Games: ${gameCount.toString()}<br>
                    Your Address: ${userAddress}<br>
                </div>`;
                
                document.getElementById('devTxList').innerHTML = html;
                
                // Chart: Games over time (mock data)
                if (devChart) devChart.destroy();
                
                const ctx = document.getElementById('devChart');
                if (ctx) {
                    devChart = new Chart(ctx.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
                            datasets: [{
                                label: 'Games Created',
                                data: [12, 19, 8, 15],
                                borderColor: 'var(--bitcoin-orange)',
                                backgroundColor: 'rgba(247, 147, 26, 0.1)',
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Dev panel error:', error);
            }
        }

        async function claimDevShare() {
            showAlert('Dev share claimed!', 'success');
        }

        async function claimMultiDevShare() {
            showAlert('Multi-dev share claimed!', 'success');
        }

        // ============= PWA INSTALL =============
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('Install prompt ready');
        });

        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choice) => {
                    if (choice.outcome === 'accepted') {
                        console.log('PWA installed');
                    }
                    deferredPrompt = null;
                });
            }
        }

        function dismissInstall() {
            document.getElementById('installPrompt').style.display = 'none';
        }

        // ============= INITIALIZATION =============
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, initializing...');
           
            // Initialize provider first
            await initializeProvider();
           
            // Rest of your initialization code...
            initTokenSelect();
            fetchPrices();
            setInterval(fetchPrices, 60000);
            loadLeaderboard();
            loadTournaments();
            updateCreateButton();
            
            // Wallet events
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', () => {
                    if (userAddress) connectWallet();
                });
                window.ethereum.on('chainChanged', () => location.reload());
            }
            
            // Real-time polling
            setInterval(() => {
                if (currentGameId) loadGame(currentGameId);
                if (isDev()) loadDevPanel();
                if (userAddress) {
                    loadUserAnalytics();
                    loadTier();
                }
            }, 10000); // 10s
            
            console.log('Initialization complete');
        });

        // ============= HELPER: ELO CALCULATION =============
        function calculateELO(playerElo, opponentElo, playerWin) {
            const k = 32;
            const expected = 1 / (1 + Math.pow(10, (opponentElo - playerElo) / 400));
            return playerElo + k * (playerWin ? 1 - expected : 0 - expected);
        }
    </script>
</body>
</html>
