// ========== CONFIGURATION & STATE ==========
const CORE_MAINNET = {
    chainId: 1116,
    rpcUrl: 'https://rpc.coredao.org',
    blockExplorerUrl: 'https://scan.coredao.org'
};

const TOKEN_CONFIG = {
    CORE:     { name: 'Core DAO', addr: '0x40375c92d9faf44d2f9db9bd9ba41a3317a2404f', decimals: 18, native: true },
    ETH:      { name: 'Ethereum', addr: '0xa4218e1f39da4aadac971066458db56e901bcbde', decimals: 18 },
    WBTC:     { name: 'Bitcoin', addr: '0x5832f53d147b3d6Cd4578B9CBD62425C7ea9d0Bd', decimals: 8 },
    USDT:     { name: 'Tether', addr: '0x900101d06a7426441ae63e9ab3b9b0f63be145f1', decimals: 6 },
    BNB:      { name: 'BNB Chain', addr: '0xdFBc618d3c48e553Cb197F42482A0795bef7fe28', decimals: 18 },
    SOL:      { name: 'Solana', addr: '0x2CAF2E77f47127db14fe74EaA00F0f9aEd44fBd7', decimals: 9 },
    XRP:      { name: 'XRP', addr: '0xa4218e1f39da4aadac971066458db56e901bcbde', decimals: 6 },
    ADA:      { name: 'Cardano', addr: '0xb577E9E300f7337d5f996a2fEc1bb5b8dE1e7d93', decimals: 6 },
    AVAX:     { name: 'Avalanche', addr: '0x', decimals: 18 },
    NEAR:     { name: 'NEAR', addr: '0x', decimals: 24 },
    LINK:     { name: 'Chainlink', addr: '0x', decimals: 18 },
    UNI:      { name: 'Uniswap', addr: '0x', decimals: 18 },
    ONDO:     { name: 'Ondo Finance', addr: '0x', decimals: 18 },
    FIL:      { name: 'Filecoin', addr: '0x', decimals: 18 },
    INJ:      { name: 'Injective', addr: '0x', decimals: 18 },
    AR:       { name: 'Arweave', addr: '0x', decimals: 12 },
    TAO:      { name: 'Bittensor', addr: '0x', decimals: 18 },
    IO:       { name: 'io.net', addr: '0x', decimals: 18 },
    VIRTUAL:  { name: 'Virtuals', addr: '0x', decimals: 18 },
    RENDER:   { name: 'Render', addr: '0x', decimals: 18 },
    HNT:      { name: 'Helium', addr: '0x', decimals: 8 },
    MAV:      { name: 'Maverick', addr: '0x', decimals: 18 },
    ZEC:      { name: 'Zcash', addr: '0x', decimals: 8 },
    DOGE:     { name: 'Dogecoin', addr: '0x', decimals: 8 },
    TON:      { name: 'Toncoin', addr: '0x', decimals: 9 },
    TRX:      { name: 'TRON', addr: '0x', decimals: 6 },
    SHIB:     { name: 'Shiba Inu', addr: '0x', decimals: 18 },
};

// Game contracts (will be set after deployment)
let HUB_ADDRESS = '0x'; // Set after deploy
let REWARDS_ADDRESS = '0x';
let NFT_ADDRESS = '0x';

// State variables
let provider = null;
let signer = null;
let userAddress = null;
let currentGameId = null;
let currentGame = null;
let gameContracts = {};

const ERC20_ABI = [
    'function approve(address spender, uint256 amount) external returns (bool)',
    'function balanceOf(address account) external view returns (uint256)',
    'function transfer(address to, uint256 amount) external returns (bool)',
    'function allowance(address owner, address spender) external view returns (uint256)'
];

// ========== WALLET MANAGEMENT ==========
async function connectWallet() {
    if (!window.ethereum) {
        showAlert('MetaMask not installed. Install it to play!', 'error');
        return;
    }

    try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        userAddress = accounts[0];

        // Setup provider and signer
        provider = new ethers.BrowserProvider(window.ethereum);
        signer = await provider.getSigner();

        // Check network
        const network = await provider.getNetwork();
        if (network.chainId !== CORE_MAINNET.chainId) {
            await switchToCoreNetwork();
        }

        updateWalletUI();
        loadAvailableGames();
        loadMyGames();
        loadDashboard();
        showAlert(`Connected: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`, 'success');
    } catch (error) {
        showAlert(`Connection failed: ${error.message}`, 'error');
    }
}

async function switchToCoreNetwork() {
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: '0x' + CORE_MAINNET.chainId.toString(16) }],
        });
    } catch (error) {
        if (error.code === 4902) {
            await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                    chainId: '0x' + CORE_MAINNET.chainId.toString(16),
                    chainName: 'Core Blockchain',
                    rpcUrls: [CORE_MAINNET.rpcUrl],
                    blockExplorerUrls: [CORE_MAINNET.blockExplorerUrl],
                    nativeCurrency: { name: 'CORE', symbol: 'CORE', decimals: 18 }
                }],
            });
        }
    }
}

function disconnectWallet() {
    userAddress = null;
    provider = null;
    signer = null;
    currentGameId = null;
    updateWalletUI();
    showAlert('Wallet disconnected', 'info');
}

function updateWalletUI() {
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const networkStatus = document.getElementById('networkStatus');
    const walletAddress = document.getElementById('walletAddress');

    if (userAddress) {
        connectBtn.style.display = 'none';
        disconnectBtn.style.display = 'block';
        networkStatus.textContent = 'üü¢ Connected';
        walletAddress.textContent = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
    } else {
        connectBtn.style.display = 'block';
        disconnectBtn.style.display = 'none';
        networkStatus.textContent = 'üî¥ Disconnected';
        walletAddress.textContent = '';
    }
}

// ========== ALERTS ==========
function showAlert(message, type = 'success') {
    const alertArea = document.getElementById('alertArea');
    const alert = document.createElement('div');
    alert.className = `alert ${type}`;
    alert.innerHTML = message;
    alertArea.appendChild(alert);

    setTimeout(() => {
        alert.style.opacity = '0';
        alert.style.transition = 'opacity 0.3s';
        setTimeout(() => alert.remove(), 300);
    }, 5000);
}

// ========== TAB SWITCHING ==========
function switchTab(tabName, btn) {
    const tabs = document.querySelectorAll('.tab-content');
    tabs.forEach(t => t.classList.remove('active'));
    document.getElementById(tabName)?.classList.add('active');

    const btns = document.querySelectorAll('.tab-btn');
    btns.forEach(b => b.classList.remove('active'));
    if (btn) btn.classList.add('active');

    if (tabName === 'token-list') {
        populateTokenList();
    } else if (tabName === 'leaderboard') {
        loadLeaderboard();
    }
}

// ========== TOKEN MANAGEMENT ==========
function populateTokenList() {
    const container = document.getElementById('tokenListContainer');
    container.innerHTML = '';

    Object.entries(TOKEN_CONFIG).forEach(([symbol, config]) => {
        const item = document.createElement('div');
        item.className = 'token-item';
        item.innerHTML = `
            <div>
                <div class="token-symbol">${symbol}</div>
                <div class="token-chain">${config.name}</div>
            </div>
            <div style="text-align:right;font-size:10px">
                ${config.native ? '‚úì Native' : 'üåâ Wrapped'}
            </div>
        `;
        container.appendChild(item);
    });
}

function updateTokenInfo() {
    const token = document.getElementById('stakeToken').value;
    const config = TOKEN_CONFIG[token];
    const infoEl = document.getElementById('tokenInfo');

    if (config.native) {
        infoEl.textContent = '‚úì Native on Core Mainnet';
        infoEl.style.color = '#10b981';
    } else {
        infoEl.textContent = 'üåâ Wrapped token via LayerZero';
        infoEl.style.color = '#f59e0b';
    }
}

// ========== GAME MANAGEMENT ==========
function updateGamePreview() {
    const gameType = document.getElementById('gameType').value;
    const title = document.getElementById('boardTitle');
    title.textContent = gameType === 'chess' ? '‚ôüÔ∏è Chess Board' : 'üî¥ Checkers Board';
}

async function createGame() {
    if (!userAddress) {
        showAlert('Connect wallet first', 'error');
        return;
    }

    const gameType = document.getElementById('gameType').value;
    const stake = document.getElementById('stakeAmount').value;
    const token = document.getElementById('stakeToken').value;
    const privacy = document.getElementById('gamePrivacy').value;
    const config = TOKEN_CONFIG[token];

    if (!stake || parseFloat(stake) < 0.01) {
        showAlert('Minimum stake is 0.01', 'error');
        return;
    }

    try {
        showAlert('Creating game on Core Mainnet...', 'info');

        // Simulate game creation (real implementation will call smart contract)
        const gameId = Math.floor(Math.random() * 1000000);
        currentGameId = gameId;

        const gameData = {
            id: gameId,
            creator: userAddress,
            player2: null,
            gameType: gameType,
            stake: stake,
            token: token,
            privacy: privacy,
            status: 'waiting',
            moves: [],
            createdAt: new Date().toISOString(),
            timeControl: document.getElementById('timeControl').value
        };

        // Store game locally for now (will be on-chain)
        localStorage.setItem(`game_${gameId}`, JSON.stringify(gameData));

        showAlert(`Game created! ID: ${gameId} | Stake: ${stake} ${token}`, 'success');

        if (privacy === 'private') {
            const link = `${window.location.origin}?gameId=${gameId}`;
            document.getElementById('shareLink').value = link;
            document.getElementById('shareLinkSection').classList.remove('hidden');
        }

        // Load the game board
        loadGame(gameId);
        loadAvailableGames();
    } catch (error) {
        showAlert(`Game creation failed: ${error.message}`, 'error');
    }
}

function copyLink() {
    const link = document.getElementById('shareLink');
    link.select();
    document.execCommand('copy');
    showAlert('Link copied to clipboard!', 'success');
}

async function loadGame(gameId) {
    try {
        const gameJson = localStorage.getItem(`game_${gameId}`);
        if (!gameJson) {
            showAlert('Game not found', 'error');
            return;
        }

        currentGame = JSON.parse(gameJson);
        currentGameId = gameId;

        // Hide creation section, show game board
        document.getElementById('gameNotLoaded').classList.add('hidden');
        document.getElementById('gameBoard').classList.remove('hidden');

        // Update game info
        document.getElementById('gameStatus').textContent = `Game ${gameId} ‚Ä¢ ${currentGame.gameType.toUpperCase()}`;
        document.getElementById('player1Info').textContent = `${currentGame.creator.slice(0, 6)}... (You)`;
        document.getElementById('player2Info').textContent = currentGame.player2 ? `${currentGame.player2.slice(0, 6)}...` : 'Waiting...';
        document.getElementById('gameStake').textContent = `${currentGame.stake} ${currentGame.token}`;

        // Render board
        renderChessBoard();
    } catch (error) {
        showAlert(`Load failed: ${error.message}`, 'error');
    }
}

function renderChessBoard() {
    const board = document.getElementById('chessBoard');
    board.innerHTML = '';

    for (let i = 0; i < 64; i++) {
        const square = document.createElement('div');
        const row = Math.floor(i / 8);
        const col = i % 8;
        const isWhite = (row + col) % 2 === 0;

        square.className = `square ${isWhite ? 'white' : ''}`;
        square.dataset.index = i;
        square.onclick = () => selectSquare(i);

        // Add piece placeholder
        if (i === 0 || i === 7) square.textContent = '‚ôú';
        if (i === 1 || i === 6) square.textContent = '‚ôò';
        if (i === 2 || i === 5) square.textContent = '‚ôó';
        if (i === 3) square.textContent = '‚ôï';
        if (i === 4) square.textContent = '‚ôî';
        if (i >= 8 && i <= 15) square.textContent = '‚ôü';

        board.appendChild(square);
    }
}

function selectSquare(index) {
    const squares = document.querySelectorAll('.square');
    squares.forEach(s => s.classList.remove('selected'));
    squares[index].classList.add('selected');

    // This will be expanded with actual move logic
    console.log(`Selected square ${index}`);
}

async function joinGame(gameId) {
    if (!userAddress) {
        showAlert('Connect wallet first', 'error');
        return;
    }

    try {
        const gameJson = localStorage.getItem(`game_${gameId}`);
        if (!gameJson) {
            showAlert('Game not found', 'error');
            return;
        }

        const game = JSON.parse(gameJson);
        if (game.creator === userAddress) {
            showAlert('Cannot join your own game', 'error');
            return;
        }

        game.player2 = userAddress;
        game.status = 'active';
        localStorage.setItem(`game_${gameId}`, JSON.stringify(game));

        showAlert('Game joined! Starting...', 'success');
        loadGame(gameId);
        loadAvailableGames();
    } catch (error) {
        showAlert(`Failed to join: ${error.message}`, 'error');
    }
}

async function loadAvailableGames() {
    if (!userAddress) return;

    try {
        const gamesList = document.getElementById('availableGamesList');
        gamesList.innerHTML = '<div class="loading" style="margin:20px"></div>';

        // Simulate loading games
        const games = [];
        for (let i = 0; i < Math.max(1, Math.random() * 5); i++) {
            games.push({
                id: Math.floor(Math.random() * 1000000),
                creator: '0x' + Array(40).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join(''),
                gameType: Math.random() > 0.5 ? 'chess' : 'checkers',
                stake: (Math.random() * 10 + 0.1).toFixed(2),
                token: 'CORE'
            });
        }

        gamesList.innerHTML = '';

        if (games.length === 0) {
            gamesList.innerHTML = '<p style="text-align:center;color:var(--text-dim)">No games available. Create one!</p>';
            return;
        }

        games.forEach(game => {
            const item = document.createElement('div');
            item.className = 'game-item';
            item.innerHTML = `
                <div>
                    <strong>${game.gameType.toUpperCase()}</strong><br>
                    ${game.creator.slice(0, 8)}... ‚Ä¢ Stake: ${game.stake} ${game.token}
                </div>
                <button onclick="joinGame(${game.id})" style="margin:0">Join</button>
            `;
            gamesList.appendChild(item);
        });
    } catch (error) {
        document.getElementById('availableGamesList').innerHTML = `<p style="color:var(--error)">${error.message}</p>`;
    }
}

async function loadMyGames() {
    if (!userAddress) return;

    try {
        const gamesList = document.getElementById('myGamesList');
        
        // Get all games from localStorage
        const games = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('game_')) {
                const game = JSON.parse(localStorage.getItem(key));
                if (game.creator === userAddress || game.player2 === userAddress) {
                    games.push(game);
                }
            }
        }

        gamesList.innerHTML = '';

        if (games.length === 0) {
            gamesList.innerHTML = '<p style="text-align:center;color:var(--text-dim)">No active games</p>';
            return;
        }

        games.forEach(game => {
            const item = document.createElement('div');
            item.className = 'game-item';
            const isCreator = game.creator === userAddress;
            const otherPlayer = isCreator ? game.player2 : game.creator;

            item.innerHTML = `
                <div>
                    <strong>${game.gameType.toUpperCase()}</strong> ‚Ä¢ ${game.status.toUpperCase()}<br>
                    vs ${otherPlayer ? otherPlayer.slice(0, 8) + '...' : 'Waiting...'}
                    <br><small>Stake: ${game.stake} ${game.token}</small>
                </div>
                <button onclick="loadGame(${game.id})" style="margin:0">Play</button>
            `;
            gamesList.appendChild(item);
        });
    } catch (error) {
        console.error(error);
    }
}

async function resignGame() {
    if (!currentGameId) return;

    try {
        showAlert('Game resigned. You lost this round.', 'warning');
        const game = JSON.parse(localStorage.getItem(`game_${currentGameId}`));
        game.status = 'resigned';
        localStorage.setItem(`game_${currentGameId}`, JSON.stringify(game));

        currentGameId = null;
        document.getElementById('gameBoard').classList.add('hidden');
        document.getElementById('gameNotLoaded').classList.remove('hidden');
    } catch (error) {
        showAlert(error.message, 'error');
    }
}

async function claimTimeout() {
    if (!currentGameId) return;
    showAlert('Timeout claimed! You won by timeout.', 'success');
    // Will record win on-chain
}

// ========== CHAT SYSTEM (ON-CHAIN) ==========
async function sendChatMessage() {
    if (!userAddress || !currentGameId) return;

    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    if (!message) return;

    try {
        // Message will be stored on-chain in the game contract
        const chatWindow = document.getElementById('chatWindow');
        const msg = document.createElement('div');
        msg.className = 'chat-message';
        msg.innerHTML = `<strong>You:</strong> ${message}`;
        chatWindow.appendChild(msg);

        input.value = '';
        chatWindow.scrollTop = chatWindow.scrollHeight;

        // Here we would call the contract to record the message
        showAlert('Message sent on-chain', 'success');
    } catch (error) {
        showAlert(error.message, 'error');
    }
}

// ========== DASHBOARD & REWARDS ==========
async function loadDashboard() {
    if (!userAddress) return;

    try {
        const wins = Math.floor(Math.random() * 50);
        const losses = Math.floor(Math.random() * 30);
        const streak = Math.floor(Math.random() * 10);

        document.getElementById('tierInfo').textContent = `${getTierName(wins)} ‚Ä¢ ${wins} Wins`;
        document.getElementById('tierProgress').style.width = `${(wins % 10) * 10}%`;
        document.getElementById('rewardsInfo').innerHTML = `
            <div><strong>Wins:</strong> ${wins}</div>
            <div><strong>Losses:</strong> ${losses}</div>
            <div><strong>Win Streak:</strong> ${streak}</div>
            <div style="margin-top:10px;color:var(--success)"><strong>Claimable:</strong> ${(wins * 0.1).toFixed(2)} CORE</strong></div>
        `;
    } catch (error) {
        console.error(error);
    }
}

function getTierName(wins) {
    if (wins >= 100) return 'üèÜ Legendary';
    if (wins >= 50) return 'üíé Diamond';
    if (wins >= 25) return 'ü•á Gold';
    if (wins >= 10) return 'ü•à Silver';
    if (wins >= 5) return 'ü•â Bronze';
    return '‚≠ê Novice';
}

async function loadLeaderboard() {
    try {
        const leaderboard = document.getElementById('leaderboardList');
        leaderboard.innerHTML = '';

        const leaders = [
            { rank: 1, name: '@ChessMaster', elo: 2850, wins: 147 },
            { rank: 2, name: '@CoreKing', elo: 2720, wins: 132 },
            { rank: 3, name: '@CheckersQueen', elo: 2650, wins: 118 },
            { rank: 4, name: '@OnChainViper', elo: 2580, wins: 95 },
            { rank: 5, name: '@BlockchainGamer', elo: 2520, wins: 87 },
        ];

        leaders.forEach(leader => {
            const item = document.createElement('div');
            item.className = 'leaderboard-item';
            item.innerHTML = `
                <div class="rank-badge">#${leader.rank}</div>
                <div style="flex:1">
                    <div><strong>${leader.name}</strong></div>
                    <div style="font-size:11px;color:var(--text-dim)">${leader.wins} wins</div>
                </div>
                <div style="text-align:right">
                    <div style="color:var(--accent);font-weight:bold">${leader.elo}</div>
                    <div style="font-size:11px;color:var(--text-dim)">ELO</div>
                </div>
            `;
            leaderboard.appendChild(item);
        });
    } catch (error) {
        console.error(error);
    }
}

function downloadStats() {
    const stats = {
        wallet: userAddress,
        exportedAt: new Date().toISOString(),
        games: [],
        totalWins: 0,
        totalLosses: 0
    };

    // Gather game data
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('game_')) {
            const game = JSON.parse(localStorage.getItem(key));
            if (game.creator === userAddress || game.player2 === userAddress) {
                stats.games.push(game);
            }
        }
    }

    const dataStr = JSON.stringify(stats, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `crossrealm-stats-${new Date().toISOString().split('T')[0]}.json`;
    link.click();

    showAlert('Stats downloaded!', 'success');
}

// ========== MODAL ==========
function closeModal() {
    document.getElementById('gameDetailModal').classList.remove('active');
}

// ========== INITIALIZATION ==========
document.addEventListener('DOMContentLoaded', () => {
    populateTokenList();
    updateTokenInfo();
    updateGamePreview();

    // Listen for wallet changes
    if (window.ethereum) {
        window.ethereum.on('accountsChanged', (accounts) => {
            if (accounts.length === 0) {
                disconnectWallet();
            } else if (accounts[0] !== userAddress) {
                connectWallet();
            }
        });

        window.ethereum.on('chainChanged', () => {
            location.reload();
        });
    }
});
