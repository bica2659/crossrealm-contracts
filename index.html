<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>CrossRealm • On-Chain Checkers & Chess on Core</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --bitcoin-orange: #f7931a;
            --burnt-orange: #cc6600;
            --core-green: #00ff88;
            --dark-bg: #0f0f0f;
            --card-bg: #1a1a1a;
            --border: #2a2a2a;
            --text: #e0e0e0;
            --text-dim: #999;
            --success: var(--core-green);
            --error: #ff4444;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            padding: 10px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            background: var(--card-bg);
            border: 2px solid var(--bitcoin-orange);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .logo {
            font-size: 28px;
            font-weight: bold;
            color: var(--bitcoin-orange);
        }
        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .wallet-status {
            font-size: 12px;
            color: var(--text-dim);
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .wallet-address {
            color: var(--bitcoin-orange);
            font-weight: bold;
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--bitcoin-orange), var(--burnt-orange));
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-family: inherit;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px var(--core-green);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .disconnect-btn {
            background: var(--error) !important;
            color: white !important;
        }
        .disconnect-btn:hover {
            box-shadow: 0 10px 30px rgba(255, 68, 68, 0.5) !important;
        }
        .tab-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 4px;
        }
        .tab-btn.active {
            background: linear-gradient(135deg, var(--bitcoin-orange), var(--burnt-orange));
            color: #000;
            border-color: var(--bitcoin-orange);
        }
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .hidden {
            display: none !important;
        }
        .board-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 400px;
            border: 2px solid var(--border);
            margin: 20px auto;
            background: #2a1810;
        }
        .square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            border: 1px solid rgba(0,0,0,0.3);
        }
        .square.light {
            background: #DEB887;
        }
        .square.dark {
            background: #8B4513;
        }
        .square.selected {
            background: #4169E1 !important;
        }
        .square.possible {
            background: #FFD700 !important;
        }
        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            border-radius: 4px;
            color: white;
            z-index: 1000;
            animation: slideIn 0.3s ease;
            max-width: 400px;
        }
        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, var(--core-green), #00cc6a);
            color: #000;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        .game-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .game-item {
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin: 15px 0;
        }
        input, select {
            padding: 10px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text);
            border-radius: 4px;
            font-family: inherit;
        }
        label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .game-info {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid var(--border);
        }
        .game-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .nft-item {
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 10px;
            text-align: center;
            border-radius: 4px;
        }
        .tournament-item {
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .leaderboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        .leader-item {
            background: var(--card-bg);
            padding: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            border-left: 3px solid var(--bitcoin-orange);
        }
        h2, h3, h4 {
            margin-bottom: 15px;
        }
        p {
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">CrossRealm</div>
            <div class="header-right">
                <div class="wallet-status" id="walletStatus">Connect Wallet</div>
                <button id="connectBtn">Connect</button>
                <button id="disconnectBtn" class="disconnect-btn hidden">Disconnect</button>
            </div>
        </div>

        <div class="tab-bar">
            <button class="tab-btn active" data-tab="home">Home</button>
            <button class="tab-btn" data-tab="games">Games</button>
            <button class="tab-btn" data-tab="tournaments">Tournaments</button>
            <button class="tab-btn" data-tab="staking">Staking</button>
            <button class="tab-btn" data-tab="nfts">NFTs</button>
            <button class="tab-btn" data-tab="profile">Profile</button>
        </div>

        <div id="home" class="tab-content">
            <div class="card">
                <h2>Welcome to CrossRealm</h2>
                <p>On-Chain Chess & Checkers with Real Stakes</p>
                <div class="stats-grid" id="globalStats"></div>
            </div>
            <div class="card">
                <h3>Create Game</h3>
                <div class="input-group">
                    <select id="gameType">
                        <option value="chess">Chess</option>
                        <option value="checkers">Checkers</option>
                    </select>
                    <input type="number" id="stakeAmount" placeholder="Stake (CORE)" min="0.1" step="0.1" value="1">
                    <label><input type="checkbox" id="isPrivate"> Private</label>
                    <label><input type="checkbox" id="isAI"> vs AI</label>
                    <button id="createGameBtn">Create Game</button>
                </div>
            </div>
        </div>

        <div id="games" class="tab-content hidden">
            <div class="card">
                <h3>Active Games</h3>
                <div id="gamesList" class="game-list"></div>
            </div>
            <div id="gameBoard" class="card hidden">
                <h3>Game Board</h3>
                <div class="game-info" id="gameInfo"></div>
                <div class="board-container" id="board"></div>
                <div class="game-controls">
                    <button id="resignBtn" style="background: var(--error); color: white;">Resign</button>
                    <button id="claimWinBtn">Claim Win</button>
                </div>
            </div>
        </div>

        <div id="tournaments" class="tab-content hidden">
            <div class="card">
                <h3>Tournaments</h3>
                <div class="input-group">
                    <input type="text" id="tournamentName" placeholder="Tournament Name">
                    <select id="tournamentGameType">
                        <option value="chess">Chess</option>
                        <option value="checkers">Checkers</option>
                    </select>
                    <input type="number" id="tournamentFee" placeholder="Entry Fee (CORE)" min="0.1" step="0.1">
                    <input type="number" id="maxPlayers" placeholder="Max Players" min="2" value="8">
                    <button id="createTournamentBtn">Create Tournament</button>
                </div>
                <div id="tournamentList"></div>
            </div>
        </div>

        <div id="staking" class="tab-content hidden">
            <div class="card">
                <h3>Staking</h3>
                <p>Stake CORE to earn 15% APY rewards</p>
                <div class="input-group">
                    <input type="number" id="stakeInput" placeholder="Amount to Stake (CORE)" min="0.1" step="0.1">
                    <button id="stakeBtn">Stake</button>
                    <button id="withdrawBtn">Withdraw</button>
                    <button id="claimRewardBtn">Claim Rewards</button>
                </div>
                <div class="stats-grid" id="stakingStats"></div>
            </div>
        </div>

        <div id="nfts" class="tab-content hidden">
            <div class="card">
                <h3>CrossRealm NFTs</h3>
                <p>Collect Win Streak NFTs</p>
                <div class="nft-grid" id="nftGrid"></div>
                <div class="input-group">
                    <input type="number" id="tokenIdInput" placeholder="Token ID" min="1">
                    <select id="equipGameType">
                        <option value="chess">Chess</option>
                        <option value="checkers">Checkers</option>
                    </select>
                    <button id="equipNftBtn">Equip NFT</button>
                </div>
            </div>
        </div>

        <div id="profile" class="tab-content hidden">
            <div class="card">
                <h3>Your Profile</h3>
                <div class="stats-grid" id="userStats"></div>
                <h4>Your Win Rate</h4>
                <p id="winRate"></p>
                <h4>Leaderboard</h4>
                <div class="leaderboard" id="leaderboard"></div>
            </div>
        </div>
    </div>

    <script>
        const app = {
            // MAINNET ADDRESSES
            HUB_ADDRESS: '0xD2Ff26ff20F8ca249b33808d85C38C16e6b9721f',
            REWARDS_ADDRESS: '0x3fd3288144DFbFa5C728fD46aF126073526a5E22',
            NFT_ADDRESS: '0x16A88d66376791a508F1aAdBc6Df4c112074EB91',
            STAKING_ADDRESS: '0xDADa11419AC555Bf840e6492C4D7a212F90249DD',
            TOURNAMENT_ADDRESS: '0xD25474e4510bc0967c0876Ef6ef5088782Bb2e4E',
            DEV_ADDRESS: '0x7adb4852c70fb86d906deb082604fc338c067135',
            CORE_TOKEN: '0x0000000000000000000000000000000000000000',

            VERIFIER_ADDRESSES: {
                chess: '0xFa1463b462d937b4F3ffD4675E1F5bA6Dac9884E',
                checkers: '0x634cBAE767EdabBa207FA7c2e790808A2bFDB3DD'
            },

            HUB_ABI: [
                "function gameCount() view returns (uint)",
                "function games(uint) view returns (tuple(uint id, string gameType, uint stake, address token, address creator, address player2, bool isAI, bool isPrivate, address referral, bool zeroGas, bool active, string fen, address verifier, uint turn))",
                "function createGame(string _gameType, uint _stake, address _token, bool _isPrivate, address _referral, bool _isAI, bool _zeroGas, address _verifier) payable",
                "function joinGame(uint _gameId) payable",
                "function makeMove(uint _gameId, string _move, string _newFen, bytes _proof) external",
                "function endGame(uint _gameId, bool _creatorWins) external"
            ],

            REWARDS_ABI: [
                "function userGamesPlayed(address) view returns (uint)",
                "function userWins(address) view returns (uint)",
                "function userLosses(address) view returns (uint)",
                "function userElo(address) view returns (uint)",
                "function claimRewards(address _user, uint _timestamp, address _token) external",
                "function getClaimableRewards(address _user, uint _timestamp, address _token) view returns (uint)"
            ],

            NFT_ABI: [
                "function balanceOf(address owner) view returns (uint256)",
                "function ownerOf(uint256 tokenId) view returns (address)",
                "function equip(uint _tokenId, string _gameType) external"
            ],

            STAKING_ABI: [
                "function stake(uint amount) external payable",
                "function withdraw(uint amount) external",
                "function getReward() external",
                "function earned(address account) view returns (uint)",
                "function balances(address) view returns (uint)",
                "function totalSupply() external view returns (uint)"
            ],

            TOURNAMENT_ABI: [
                "function tournamentCount() view returns (uint)",
                "function tournaments(uint) view returns (tuple(uint id, string name, string gameType, uint entryFee, address token, uint maxPlayers, uint prizePool, address[] participants, bool active, address winner, uint startTime, uint endTime))",
                "function createTournament(string _name, string _gameType, uint _entryFee, address _token, uint _maxPlayers, uint _durationHours) external payable",
                "function joinTournament(uint _tournamentId) external payable",
                "function endTournament(uint _tournamentId, address _winner) external"
            ],

            provider: null,
            signer: null,
            userAddress: null,
            hubContract: null,
            rewardsContract: null,
            nftContract: null,
            stakingContract: null,
            tournamentContract: null,
            currentGameId: null,
            currentGame: null,
            selectedSquare: null,
            gameChess: null,

            pieceSymbols: {
                'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
                'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
            },

            async init() {
                this.setupEventListeners();
            },

            setupEventListeners() {
                document.getElementById('connectBtn').onclick = () => this.connectWallet();
                document.getElementById('disconnectBtn').onclick = () => this.disconnect();
                
                // Games
                document.getElementById('createGameBtn').onclick = () => this.createGame();
                document.getElementById('resignBtn').onclick = () => this.resignGame();
                document.getElementById('claimWinBtn').onclick = () => this.claimWin();

                // Tournaments
                document.getElementById('createTournamentBtn').onclick = () => this.createTournament();

                // Staking
                document.getElementById('stakeBtn').onclick = () => this.stake();
                document.getElementById('withdrawBtn').onclick = () => this.withdraw();
                document.getElementById('claimRewardBtn').onclick = () => this.claimStakingRewards();

                // NFTs
                document.getElementById('equipNftBtn').onclick = () => this.equipNFT();

                // Tabs
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.onclick = (e) => this.switchTab(e.target.dataset.tab);
                });
            },

            async connectWallet() {
                try {
                    if (!window.ethereum) {
                        this.alert('Please install MetaMask!', 'error');
                        return;
                    }
                    this.provider = new ethers.providers.Web3Provider(window.ethereum);
                    await this.provider.send("eth_requestAccounts", []);
                    this.signer = this.provider.getSigner();
                    this.userAddress = await this.signer.getAddress();
                    
                    this.hubContract = new ethers.Contract(this.HUB_ADDRESS, this.HUB_ABI, this.signer);
                    this.rewardsContract = new ethers.Contract(this.REWARDS_ADDRESS, this.REWARDS_ABI, this.signer);
                    this.nftContract = new ethers.Contract(this.NFT_ADDRESS, this.NFT_ABI, this.signer);
                    this.stakingContract = new ethers.Contract(this.STAKING_ADDRESS, this.STAKING_ABI, this.signer);
                    this.tournamentContract = new ethers.Contract(this.TOURNAMENT_ADDRESS, this.TOURNAMENT_ABI, this.signer);
                    
                    this.updateWallet();
                    this.loadGlobalStats();
                    this.alert('Wallet connected!', 'success');
                } catch (error) {
                    this.alert('Connection failed: ' + error.message, 'error');
                }
            },

            disconnect() {
                this.userAddress = null;
                this.signer = null;
                this.updateWallet();
                this.alert('Disconnected', 'info');
            },

            updateWallet() {
                const statusEl = document.getElementById('walletStatus');
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                if (this.userAddress) {
                    statusEl.innerHTML = `<span class="wallet-address">${this.userAddress.slice(0,6)}...${this.userAddress.slice(-4)}</span>`;
                    connectBtn.classList.add('hidden');
                    disconnectBtn.classList.remove('hidden');
                } else {
                    statusEl.textContent = 'Connect Wallet';
                    connectBtn.classList.remove('hidden');
                    disconnectBtn.classList.add('hidden');
                }
            },

            switchTab(tabName) {
                document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(tabName).classList.remove('hidden');
                event.target.classList.add('active');

                if (tabName === 'games') this.loadGames();
                if (tabName === 'tournaments') this.loadTournaments();
                if (tabName === 'staking') this.loadStakingStats();
                if (tabName === 'nfts') this.loadNFTs();
                if (tabName === 'profile') this.loadProfile();
            },

            async loadGlobalStats() {
                try {
                    if (!this.hubContract) return;
                    const gameCount = await this.hubContract.gameCount();
                    const stakingSupply = await this.stakingContract.totalSupply();
                    
                    document.getElementById('globalStats').innerHTML = `
                        <div class="stat-card">Total Games<br>${gameCount}</div>
                        <div class="stat-card">Total Staked<br>${ethers.utils.formatEther(stakingSupply)} CORE</div>
                        <div class="stat-card">APY Rewards<br>15%</div>
                        <div class="stat-card">Active Players<br>256+</div>
                    `;
                } catch (e) {
                    console.error('Stats error:', e);
                }
            },

            async loadGames() {
                const listEl = document.getElementById('gamesList');
                try {
                    if (!this.hubContract) {
                        listEl.innerHTML = '<p>Connect wallet to view games</p>';
                        return;
                    }
                    const count = await this.hubContract.gameCount();
                    let html = '';
                    
                    for (let i = count.toNumber(); i >= Math.max(1, count.toNumber() - 20); i--) {
                        try {
                            const game = await this.hubContract.games(i);
                            if (game.active) {
                                const opponent = game.player2 === '0x0000000000000000000000000000000000000000' 
                                    ? 'Open' : game.player2.slice(0, 6) + '...';
                                const isMyGame = game.creator.toLowerCase() === this.userAddress?.toLowerCase() ||
                                               game.player2.toLowerCase() === this.userAddress?.toLowerCase();
                                const canJoin = game.player2 === '0x0000000000000000000000000000000000000000' && 
                                               game.creator.toLowerCase() !== this.userAddress?.toLowerCase();
                                
                                html += `
                                    <div class="game-item">
                                        <div>
                                            <strong>${game.gameType.toUpperCase()} #${i}</strong><br>
                                            Stake: ${ethers.utils.formatEther(game.stake)} CORE<br>
                                            Opponent: ${opponent}
                                        </div>
                                        <div>
                                            ${isMyGame ? '<span style="color: var(--core-green);">Your Game</span>' : ''}
                                            ${canJoin ? `<button onclick="window.app.joinGame(${i})" style="margin: 0 5px;">Join</button>` : ''}
                                            <button onclick="window.app.viewGame(${i})">View</button>
                                        </div>
                                    </div>
                                `;
                            }
                        } catch (e) {
                            console.error('Game load error:', e);
                        }
                    }
                    listEl.innerHTML = html || '<p>No active games</p>';
                } catch (e) {
                    console.error('Load games error:', e);
                    listEl.innerHTML = '<p>Error loading games</p>';
                }
            },

            async viewGame(id) {
                try {
                    if (!this.hubContract) return;
                    this.currentGameId = id;
                    this.currentGame = await this.hubContract.games(id);
                    
                    if (!this.currentGame.active) {
                        this.alert('Game is not active', 'error');
                        return;
                    }
                    
                    document.getElementById('gameBoard').classList.remove('hidden');
                    
                    const opponent = this.currentGame.player2 === '0x0000000000000000000000000000000000000000' 
                        ? 'Open' : this.currentGame.player2.slice(0, 6) + '...';
                    
                    document.getElementById('gameInfo').innerHTML = `
                        <h4>Game #${id}</h4>
                        <p><strong>Type:</strong> ${this.currentGame.gameType}</p>
                        <p><strong>Stake:</strong> ${ethers.utils.formatEther(this.currentGame.stake)} CORE</p>
                        <p><strong>Opponent:</strong> ${opponent}</p>
                        <p><strong>Turn:</strong> ${this.currentGame.turn === 0 ? 'Creator' : 'Player 2'}</p>
                    `;
                    
                    this.renderBoard();
                } catch (e) {
                    console.error('View game error:', e);
                    this.alert('Error loading game: ' + e.message, 'error');
                }
            },

            renderBoard() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                
                try {
                    if (this.currentGame.gameType === 'chess') {
                        this.gameChess = new Chess(this.currentGame.fen);
                        const board = this.gameChess.board();
                        
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 8; col++) {
                                const square = document.createElement('div');
                                square.className = `square ${((7-row) + col) % 2 === 0 ? 'light' : 'dark'}`;
                                square.dataset.row = row;
                                square.dataset.col = col;
                                
                                const piece = board[row][col];
                                if (piece) {
                                    const key = piece.color === 'w' 
                                        ? piece.type.toUpperCase() 
                                        : piece.type.toLowerCase();
                                    square.textContent = this.pieceSymbols[key] || '';
                                }
                                
                                square.onclick = () => this.handleSquareClick(square);
                                boardEl.appendChild(square);
                            }
                        }
                    } else {
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 8; col++) {
                                const square = document.createElement('div');
                                square.className = `square ${(row + col) % 2 === 0 ? 'dark' : 'light'}`;
                                square.dataset.row = row;
                                square.dataset.col = col;
                                
                                if (row < 3 && (row + col) % 2 === 0) {
                                    square.textContent = '●';
                                    square.style.color = '#000';
                                } else if (row > 4 && (row + col) % 2 === 1) {
                                    square.textContent = '○';
                                    square.style.color = '#fff';
                                }
                                
                                boardEl.appendChild(square);
                            }
                        }
                    }
                } catch (e) {
                    console.error('Board render error:', e);
                    boardEl.innerHTML = '<p>Error rendering board</p>';
                }
            },

            handleSquareClick(squareEl) {
                const row = parseInt(squareEl.dataset.row);
                const col = parseInt(squareEl.dataset.col);
                
                if (this.selectedSquare) {
                    this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                    this.selectedSquare = null;
                    this.clearHighlights();
                } else {
                    this.selectedSquare = {row, col};
                    squareEl.classList.add('selected');
                }
            },

            async makeMove(fromRow, fromCol, toRow, toCol) {
                try {
                    if (!this.hubContract) return;
                    
                    if (this.currentGame.gameType === 'chess' && this.gameChess) {
                        const from = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                        const to = String.fromCharCode(97 + toCol) + (8 - toRow);
                        const move = this.gameChess.move({from, to, promotion: 'q'});
                        
                        if (!move) {
                            this.alert('Invalid move', 'error');
                            return;
                        }
                        
                        const newFen = this.gameChess.fen();
                        const tx = await this.hubContract.makeMove(this.currentGameId, move.san, newFen, '0x');
                        this.alert('Move submitted...', 'info');
                        await tx.wait();
                        this.alert('Move executed!', 'success');
                        this.viewGame(this.currentGameId);
                    }
                } catch (e) {
                    console.error('Move error:', e);
                    this.alert('Move failed: ' + e.message, 'error');
                }
            },

            clearHighlights() {
                document.querySelectorAll('.square').forEach(sq => {
                    sq.classList.remove('selected', 'possible');
                });
            },

            async createGame() {
                try {
                    if (!this.hubContract || !this.userAddress) {
                        this.alert('Connect wallet first', 'error');
                        return;
                    }
                    
                    const gameType = document.getElementById('gameType').value;
                    const stakeStr = document.getElementById('stakeAmount').value;
                    
                    if (!stakeStr || parseFloat(stakeStr) <= 0) {
                        this.alert('Enter valid stake amount', 'error');
                        return;
                    }
                    
                    const stake = ethers.utils.parseEther(stakeStr);
                    const isPrivate = document.getElementById('isPrivate').checked;
                    const isAI = document.getElementById('isAI').checked;
                    const verifier = this.VERIFIER_ADDRESSES[gameType];
                    
                    const tx = await this.hubContract.createGame(
                        gameType, stake, this.CORE_TOKEN, isPrivate,
                        ethers.constants.AddressZero, isAI, false, verifier,
                        { value: stake }
                    );
                    
                    this.alert('Creating game...', 'info');
                    await tx.wait();
                    this.alert('Game created!', 'success');
                    document.getElementById('stakeAmount').value = '';
                    this.loadGames();
                } catch (e) {
                    this.alert('Create failed: ' + (e.reason || e.message), 'error');
                }
            },

            async joinGame(id) {
                try {
                    if (!this.hubContract) return;
                    const game = await this.hubContract.games(id);
                    const tx = await this.hubContract.joinGame(id, { value: game.stake });
                    this.alert('Joining game...', 'info');
                    await tx.wait();
                    this.alert('Joined!', 'success');
                    this.loadGames();
                } catch (e) {
                    this.alert('Join failed: ' + e.message, 'error');
                }
            },

            async claimWin() {
                try {
                    if (!this.hubContract) return;
                    const creatorWins = confirm('Did the creator win?');
                    const tx = await this.hubContract.endGame(this.currentGameId, creatorWins);
                    this.alert('Ending game...', 'info');
                    await tx.wait();
                    this.alert('Game ended! NFT will be minted for winner.', 'success');
                    document.getElementById('gameBoard').classList.add('hidden');
                    this.loadGames();
                } catch (e) {
                    this.alert('End game failed: ' + e.message, 'error');
                }
            },

            resignGame() {
                if (confirm('Resign and lose this game?')) {
                    this.claimWin();
                }
            },

            async loadTournaments() {
                const listEl = document.getElementById('tournamentList');
                try {
                    if (!this.tournamentContract) {
                        listEl.innerHTML = '<p>Connect wallet to view tournaments</p>';
                        return;
                    }
                    const count = await this.tournamentContract.tournamentCount();
                    let html = '';
                    
                    for (let i = count.toNumber(); i >= Math.max(1, count.toNumber() - 10); i--) {
                        try {
                            const tour = await this.tournamentContract.tournaments(i);
                            if (tour.active) {
                                html += `
                                    <div class="tournament-item">
                                        <h4>${tour.name}</h4>
                                        <p><strong>Type:</strong> ${tour.gameType}</p>
                                        <p><strong>Entry Fee:</strong> ${ethers.utils.formatEther(tour.entryFee)} CORE</p>
                                        <p><strong>Players:</strong> ${tour.participants.length}/${tour.maxPlayers}</p>
                                        <p><strong>Prize Pool:</strong> ${ethers.utils.formatEther(tour.prizePool)} CORE</p>
                                        <button onclick="window.app.joinTournament(${i})">Join</button>
                                    </div>
                                `;
                            }
                        } catch (e) {
                            console.error('Tournament load error:', e);
                        }
                    }
                    listEl.innerHTML = html || '<p>No active tournaments</p>';
                } catch (e) {
                    console.error('Load tournaments error:', e);
                    listEl.innerHTML = '<p>Error loading tournaments</p>';
                }
            },

            async createTournament() {
                try {
                    if (!this.tournamentContract) return;
                    if (this.userAddress.toLowerCase() !== this.DEV_ADDRESS.toLowerCase()) {
                        this.alert('Only owner can create tournaments', 'error');
                        return;
                    }

                    const name = document.getElementById('tournamentName').value;
                    const gameType = document.getElementById('tournamentGameType').value;
                    const feeStr = document.getElementById('tournamentFee').value;
                    const maxPlayers = parseInt(document.getElementById('maxPlayers').value);

                    if (!name || !feeStr || !maxPlayers) {
                        this.alert('Fill all tournament fields', 'error');
                        return;
                    }

                    const entryFee = ethers.utils.parseEther(feeStr);
                    const tx = await this.tournamentContract.createTournament(
                        name, gameType, entryFee, this.CORE_TOKEN, maxPlayers, 24,
                        { value: ethers.utils.parseEther('0') }
                    );

                    this.alert('Creating tournament...', 'info');
                    await tx.wait();
                    this.alert('Tournament created!', 'success');
                    document.getElementById('tournamentName').value = '';
                    document.getElementById('tournamentFee').value = '';
                    this.loadTournaments();
                } catch (e) {
                    this.alert('Create tournament failed: ' + e.message, 'error');
                }
            },

            async joinTournament(id) {
                try {
                    if (!this.tournamentContract) return;
                    const tour = await this.tournamentContract.tournaments(id);
                    const tx = await this.tournamentContract.joinTournament(id, { value: tour.entryFee });
                    this.alert('Joining tournament...', 'info');
                    await tx.wait();
                    this.alert('Joined tournament!', 'success');
                    this.loadTournaments();
                } catch (e) {
                    this.alert('Join tournament failed: ' + e.message, 'error');
                }
            },

            async loadStakingStats() {
                try {
                    if (!this.stakingContract || !this.userAddress) return;
                    const balance = await this.stakingContract.balances(this.userAddress);
                    const earned = await this.stakingContract.earned(this.userAddress);
                    
                    document.getElementById('stakingStats').innerHTML = `
                        <div class="stat-card">Staked CORE<br>${ethers.utils.formatEther(balance)}</div>
                        <div class="stat-card">Pending Rewards<br>${ethers.utils.formatEther(earned)}</div>
                        <div class="stat-card">APY<br>15%</div>
                    `;
                } catch (e) {
                    console.error('Staking stats error:', e);
                }
            },

            async stake() {
                try {
                    if (!this.stakingContract) return;
                    const amountStr = document.getElementById('stakeInput').value;
                    if (!amountStr || parseFloat(amountStr) <= 0) {
                        this.alert('Enter valid amount', 'error');
                        return;
                    }
                    
                    const amount = ethers.utils.parseEther(amountStr);
                    const tx = await this.stakingContract.stake(amount, { value: amount });
                    this.alert('Staking...', 'info');
                    await tx.wait();
                    this.alert('Staked successfully!', 'success');
                    document.getElementById('stakeInput').value = '';
                    this.loadStakingStats();
                } catch (e) {
                    this.alert('Staking failed: ' + e.message, 'error');
                }
            },

            async withdraw() {
                try {
                    if (!this.stakingContract) return;
                    const amountStr = document.getElementById('stakeInput').value;
                    if (!amountStr || parseFloat(amountStr) <= 0) {
                        this.alert('Enter valid amount', 'error');
                        return;
                    }
                    
                    const amount = ethers.utils.parseEther(amountStr);
                    const tx = await this.stakingContract.withdraw(amount);
                    this.alert('Withdrawing...', 'info');
                    await tx.wait();
                    this.alert('Withdrawn!', 'success');
                    document.getElementById('stakeInput').value = '';
                    this.loadStakingStats();
                } catch (e) {
                    this.alert('Withdraw failed: ' + e.message, 'error');
                }
            },

            async claimStakingRewards() {
                try {
                    if (!this.stakingContract) return;
                    const tx = await this.stakingContract.getReward();
                    this.alert('Claiming rewards...', 'info');
                    await tx.wait();
                    this.alert('Rewards claimed!', 'success');
                    this.loadStakingStats();
                } catch (e) {
                    this.alert('Claim failed: ' + e.message, 'error');
                }
            },

            async loadNFTs() {
                if (!this.userAddress) {
                    document.getElementById('nftGrid').innerHTML = '<p>Connect wallet to view NFTs</p>';
                    return;
                }
                try {
                    if (!this.nftContract) return;
                    const balance = await this.nftContract.balanceOf(this.userAddress);
                    let html = '';
                    
                    for (let i = 1; i <= balance.toNumber(); i++) {
                        try {
                            const owner = await this.nftContract.ownerOf(i);
                            if (owner.toLowerCase() === this.userAddress.toLowerCase()) {
                                html += `<div class="nft-item"><strong>Streak NFT #${i}</strong></div>`;
                            }
                        } catch (e) {}
                    }
                    
                    document.getElementById('nftGrid').innerHTML = html || '<p>No NFTs owned yet</p>';
                } catch (e) {
                    console.error('Load NFTs error:', e);
                }
            },

            async equipNFT() {
                try {
                    if (!this.nftContract) return;
                    const tokenId = parseInt(document.getElementById('tokenIdInput').value);
                    const gameType = document.getElementById('equipGameType').value;
                    
                    if (!tokenId || tokenId <= 0) {
                        this.alert('Enter valid token ID', 'error');
                        return;
                    }
                    
                    const tx = await this.nftContract.equip(tokenId, gameType);
                    this.alert('Equipping NFT...', 'info');
                    await tx.wait();
                    this.alert('NFT equipped!', 'success');
                } catch (e) {
                    this.alert('Equip failed: ' + e.message, 'error');
                }
            },

            async loadProfile() {
                if (!this.userAddress) {
                    document.getElementById('userStats').innerHTML = '<p>Connect wallet to view profile</p>';
                    return;
                }
                try {
                    if (!this.rewardsContract) return;
                    
                    const games = await this.rewardsContract.userGamesPlayed(this.userAddress);
                    const wins = await this.rewardsContract.userWins(this.userAddress);
                    const losses = await this.rewardsContract.userLosses(this.userAddress);
                    const elo = await this.rewardsContract.userElo(this.userAddress);
                    
                    const winRate = games.toNumber() > 0 
                        ? ((wins.toNumber() / games.toNumber()) * 100).toFixed(1) 
                        : 0;
                    
                    document.getElementById('userStats').innerHTML = `
                        <div class="stat-card">Games Played<br>${games}</div>
                        <div class="stat-card">Wins<br>${wins}</div>
                        <div class="stat-card">Losses<br>${losses}</div>
                        <div class="stat-card">ELO<br>${elo}</div>
                    `;
                    
                    document.getElementById('winRate').innerHTML = `<strong>${winRate}%</strong>`;
                    
                    // Mock leaderboard
                    document.getElementById('leaderboard').innerHTML = `
                        <div class="leader-item"><span>1. Your Rank</span><span>ELO: ${elo}</span></div>
                        <div class="leader-item"><span>2. @Player2</span><span>ELO: 1450</span></div>
                        <div class="leader-item"><span>3. @Player3</span><span>ELO: 1400</span></div>
                        <div class="leader-item"><span>4. @Player4</span><span>ELO: 1350</span></div>
                        <div class="leader-item"><span>5. @Player5</span><span>ELO: 1300</span></div>
                    `;
                } catch (e) {
                    console.error('Load profile error:', e);
                }
            },

            alert(msg, type = 'success') {
                const alertEl = document.createElement('div');
                alertEl.className = 'alert';
                alertEl.style.background = type === 'success' ? '#00cc6a' : type === 'error' ? '#ff4444' : '#f7931a';
                alertEl.textContent = msg;
                document.body.appendChild(alertEl);
                setTimeout(() => alertEl.remove(), 4000);
            }
        };

        // Start app
        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
