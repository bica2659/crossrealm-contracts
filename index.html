<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>CrossRealm • On-Chain Checkers & Chess on Core</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiQ3Jvc3NSZWFsbSIsInNob3J0X25hbWUiOiJDUlIiLCJzdGFydF91cmwiOiIvIiwiZGlzcGxheSI6ImZ1bGxzY3JlZW4iLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzBmMGYwZiIsInRoZW1lX2NvbG9yIjoiI2Y3OTMxYSJ9">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --bitcoin-orange: #f7931a;
            --burnt-orange: #cc6600;
            --core-green: #00ff88;
            --dark-bg: #0f0f0f;
            --card-bg: #1a1a1a;
            --border: #2a2a2a;
            --text: #e0e0e0;
            --text-dim: #999;
            --success: var(--core-green);
            --error: #ff4444;
            --gradient-primary: linear-gradient(135deg, var(--bitcoin-orange), var(--burnt-orange));
            --gradient-success: linear-gradient(135deg, var(--core-green), #00cc6a);
            --wood-light: #DEB887;
            --wood-dark: #8B4513;
            --highlight-selected: #4169E1;
            --highlight-possible: #FFD700;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            padding: 10px;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(247, 147, 26, 0.03) 2px, rgba(247, 147, 26, 0.03) 4px);
            overflow-x: hidden;
        }
        body.light-theme {
            --dark-bg: #f0f0f0;
            --card-bg: #ffffff;
            --border: #ddd;
            --text: #333;
            --text-dim: #666;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            background: var(--card-bg);
            border: 2px solid var(--bitcoin-orange);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(247, 147, 26, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }
        .logo {
            font-size: 28px;
            font-weight: bold;
            color: var(--bitcoin-orange);
            margin-bottom: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 1;
            text-align: center;
        }
        .tagline {
            color: var(--text-dim);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            position: relative;
            z-index: 1;
            text-align: center;
        }
        .wallet-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
            z-index: 1;
        }
        .wallet-status {
            font-size: 11px;
            color: var(--text-dim);
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        .wallet-address {
            color: var(--bitcoin-orange);
            font-weight: bold;
        }
        button {
            background: var(--gradient-primary);
            color: #000;
            border: none;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            min-height: 44px;
            line-height: 1.2;
            border-radius: 4px;
        }
        button:hover, button:active {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px var(--core-green);
        }
        button:disabled {
            background: var(--border);
            color: var(--text-dim);
            cursor: not-allowed;
            opacity: 0.5;
        }
        .disconnect-btn, .resign-btn {
            background: var(--error);
            color: white;
        }
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .tab-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .tab-btn {
            padding: 10px 20px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            cursor: pointer;
        }
        .tab-btn.active {
            background: var(--gradient-primary);
            color: #000;
            border-color: var(--bitcoin-orange);
        }
        .hidden {
            display: none !important;
        }
        .board-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 400px;
            border: 2px solid var(--border);
            margin: 20px auto;
            background: var(--wood-dark);
        }
        .square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .square.light {
            background: var(--wood-light);
        }
        .square.dark {
            background: var(--wood-dark);
        }
        .square.selected {
            background: var(--highlight-selected) !important;
        }
        .square.possible {
            background: var(--highlight-possible) !important;
        }
        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            border-radius: 4px;
            color: white;
            z-index: 1000;
            animation: slideIn 0.3s ease;
            max-width: 400px;
        }
        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: var(--gradient-success);
            color: #000;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        .nft-item {
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 10px;
            text-align: center;
            border-radius: 4px;
        }
        .tournament-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 10px;
        }
        input, select {
            padding: 10px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text);
            border-radius: 4px;
            font-family: inherit;
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .game-info {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid var(--border);
            text-align: center;
        }
        .game-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .leader-item {
            background: var(--card-bg);
            padding: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            border-left: 3px solid var(--bitcoin-orange);
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="logo">CrossRealm</h1>
            <p class="tagline">On-Chain Checkers & Chess on Core</p>
            <div class="wallet-bar">
                <div class="wallet-status" id="walletStatus">Connect Wallet</div>
                <button id="connectBtn">Connect</button>
                <button id="disconnectBtn" class="disconnect-btn hidden">Disconnect</button>
            </div>
        </div>

        <div class="tab-bar">
            <button class="tab-btn active" data-tab="home">Home</button>
            <button class="tab-btn" data-tab="games">Games</button>
            <button class="tab-btn" data-tab="tournaments">Tournaments</button>
            <button class="tab-btn" data-tab="staking">Staking</button>
            <button class="tab-btn" data-tab="nfts">NFTs</button>
            <button class="tab-btn" data-tab="profile">Profile</button>
        </div>

        <div id="home" class="tab-content">
            <div class="card">
                <h2>Welcome to CrossRealm</h2>
                <p>Play on-chain chess and checkers with staking and rewards.</p>
                <div class="stats-grid" id="globalStats"></div>
                <div id="leaderboard"></div>
            </div>
            <div class="card">
                <h3>Create Game</h3>
                <div class="input-group">
                    <select id="gameType">
                        <option value="chess">Chess</option>
                        <option value="checkers">Checkers</option>
                    </select>
                    <input type="number" id="stakeAmount" placeholder="Stake (CORE)" min="0.1" step="0.1">
                    <label><input type="checkbox" id="isPrivate"> Private</label>
                    <label><input type="checkbox" id="isAI"> vs AI</label>
                </div>
                <div class="input-group">
                    <input type="text" id="referral" placeholder="Referral Address (optional)">
                    <button id="createGameBtn">Create Game</button>
                </div>
            </div>
            <div class="card">
                <h3>Quick Actions</h3>
                <button id="toggleThemeBtn">Toggle Theme</button>
                <button id="shareBtn">Share</button>
            </div>
        </div>

        <div id="games" class="tab-content hidden">
            <div class="card">
                <h3>Active Games</h3>
                <div id="gamesList"></div>
            </div>
            <div id="gameBoard" class="hidden">
                <div class="card">
                    <div class="game-info" id="gameInfo"></div>
                    <div class="board-container" id="board"></div>
                    <div class="game-controls">
                        <button id="resignBtn" class="resign-btn">Resign</button>
                        <button id="claimWinBtn">Claim Win</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="tournaments" class="tab-content hidden">
            <div class="card">
                <h3>Tournaments</h3>
                <button id="createTournamentBtn">Create Tournament</button>
                <div id="tournamentList"></div>
            </div>
        </div>

        <div id="staking" class="tab-content hidden">
            <div class="card">
                <h3>Staking</h3>
                <p>Stake CORE to earn rewards.</p>
                <div class="input-group">
                    <input type="number" id="stakeInput" placeholder="Amount to stake" min="0.1" step="0.1">
                    <button id="stakeBtn">Stake</button>
                    <button id="withdrawBtn">Withdraw</button>
                    <button id="claimStakeRewardBtn">Claim Rewards</button>
                </div>
                <div id="stakingStats"></div>
            </div>
        </div>

        <div id="nfts" class="tab-content hidden">
            <div class="card">
                <h3>CrossRealm NFTs</h3>
                <p>Collect win streak NFTs.</p>
                <div class="nft-grid" id="nftGrid"></div>
                <div class="input-group">
                    <input type="number" id="tokenIdInput" placeholder="Token ID" min="1">
                    <select id="equipGameType">
                        <option value="chess">Chess</option>
                        <option value="checkers">Checkers</option>
                    </select>
                    <button id="equipNftBtn">Equip NFT</button>
                </div>
            </div>
        </div>

        <div id="profile" class="tab-content hidden">
            <div class="card">
                <h3>Profile</h3>
                <div id="userStats"></div>
                <div id="userAnalytics"></div>
                <button id="claimRewardsBtn">Claim Rewards</button>
            </div>
        </div>
    </div>

    <script>
        // Fixed: Core issue - game board not showing after creation
        window.crossRealmApp = {
            // MAINNET ADDRESSES - DO NOT CHANGE
            HUB_ADDRESS: '0xD2Ff26ff20F8ca249b33808d85C38C16e6b9721f',
            REWARDS_ADDRESS: '0x3fd3288144DFbFa5C728fD46aF126073526a5E22',
            NFT_ADDRESS: '0x16A88d66376791a508F1aAdBc6Df4c112074EB91',
            STAKING_ADDRESS: '0xDADa11419AC555Bf840e6492C4D7a212F90249DD',
            TOURNAMENT_ADDRESS: '0xD25474e4510bc0967c0876Ef6ef5088782Bb2e4E',
            VERIFIER_ADDRESSES: {
                chess: '0xFa1463b462d937b4F3ffD4675E1F5bA6Dac9884E',
                checkers: '0x634cBAE767EdabBa207FA7c2e790808A2bFDB3DD',
                fighting: '0x0000000000000000000000000000000000000000',
                carrace: '0x0000000000000000000000000000000000000000'
            },
            DEV_ADDRESS: '0x7adb4852c70fb86d906deb082604fc338c067135',
            CORE_TOKEN: '0x0000000000000000000000000000000000000000',

            // ABIs
            HUB_ABI: [
                "function gameCount() view returns (uint)",
                "function games(uint) view returns (tuple(uint id, string gameType, uint stake, address token, address creator, address player2, bool isAI, bool isPrivate, address referral, bool zeroGas, bool active, string fen, address verifier, uint turn))",
                "function createGame(string _gameType, uint _stake, address _token, bool _isPrivate, address _referral, bool _isAI, bool _zeroGas, address _verifier) payable",
                "function joinGame(uint _gameId) payable",
                "function makeMove(uint _gameId, string _move, string _newFen, bytes _proof) external",
                "function endGame(uint _gameId, bool _creatorWins) external"
            ],

            REWARDS_ABI: [
                "function userGamesPlayed(address) view returns (uint)",
                "function userWins(address) view returns (uint)",
                "function userLosses(address) view returns (uint)",
                "function userElo(address) view returns (uint)"
            ],

            NFT_ABI: [
                "function balanceOf(address owner) view returns (uint256)",
                "function ownerOf(uint256 tokenId) view returns (address)",
                "function equip(uint _tokenId, string _gameType) external"
            ],

            STAKING_ABI: [
                "function stake(uint amount) external payable",
                "function withdraw(uint amount) external",
                "function getReward() external",
                "function earned(address account) view returns (uint)",
                "function balances(address) view returns (uint)"
            ],

            // Global vars
            provider: null,
            signer: null,
            userAddress: null,
            hubContract: null,
            rewardsContract: null,
            nftContract: null,
            stakingContract: null,
            currentGameId: null,
            currentGame: null,
            selectedSquare: null,
            gameChess: null,
            userStats: { wins: 0, losses: 0, elo: 1200, games: 0 },
            difficulty: 3,
            pollInterval: null,

            pieceSymbols: {
                'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
                'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
            },

            // Initialize
            initializeProvider: async function() {
                try {
                    if (!window.ethereum) {
                        this.showAlert('Please install MetaMask!', 'error');
                        return;
                    }
                    this.provider = new ethers.providers.Web3Provider(window.ethereum);
                    await this.provider.send("eth_requestAccounts", []);
                    this.signer = this.provider.getSigner();
                    this.userAddress = await this.signer.getAddress();
                    this.initContracts();
                    this.updateWalletStatus();
                    this.loadUserStats();
                    this.startPolling();
                } catch (error) {
                    console.error('Init error:', error);
                    this.showAlert('Connection failed', 'error');
                }
            },

            initContracts: function() {
                this.hubContract = new ethers.Contract(this.HUB_ADDRESS, this.HUB_ABI, this.signer);
                this.rewardsContract = new ethers.Contract(this.REWARDS_ADDRESS, this.REWARDS_ABI, this.signer);
                this.nftContract = new ethers.Contract(this.NFT_ADDRESS, this.NFT_ABI, this.signer);
                this.stakingContract = new ethers.Contract(this.STAKING_ADDRESS, this.STAKING_ABI, this.signer);
            },

            updateWalletStatus: function() {
                const statusEl = document.getElementById('walletStatus');
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                if (this.userAddress) {
                    statusEl.innerHTML = `<span class="wallet-address">${this.userAddress.slice(0,6)}...${this.userAddress.slice(-4)}</span>`;
                    connectBtn.classList.add('hidden');
                    disconnectBtn.classList.remove('hidden');
                } else {
                    statusEl.innerHTML = 'Connect Wallet';
                    connectBtn.classList.remove('hidden');
                    disconnectBtn.classList.add('hidden');
                }
            },

            // Wallet events
            setupWalletListeners: function() {
                document.getElementById('connectBtn').onclick = () => this.initializeProvider();
                document.getElementById('disconnectBtn').onclick = () => {
                    this.userAddress = null;
                    this.signer = null;
                    this.updateWalletStatus();
                    this.showAlert('Disconnected', 'info');
                };

                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', () => this.initializeProvider());
                    window.ethereum.on('chainChanged', () => location.reload());
                }
            },

            // Tabs
            setupTabs: function() {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', e => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                        const tabId = e.target.dataset.tab;
                        document.getElementById(tabId).classList.remove('hidden');
                        
                        if (tabId === 'home') {
                            this.loadGlobalStats();
                            this.loadLeaderboard();
                        } else if (tabId === 'games') {
                            this.loadGames();
                        } else if (tabId === 'profile') {
                            this.loadProfile();
                        }
                    });
                });
            },

            // HOME
            loadGlobalStats: async function() {
                try {
                    if (!this.hubContract) return;
                    const gameCount = await this.hubContract.gameCount();
                    const statsHtml = `
                        <div class="stat-card">Total Games<br>${gameCount.toString()}</div>
                        <div class="stat-card">Active Users<br>Loading...</div>
                        <div class="stat-card">Total Staked<br>Loading...</div>
                        <div class="stat-card">NFTs Minted<br>Loading...</div>
                    `;
                    document.getElementById('globalStats').innerHTML = statsHtml;
                } catch (e) {
                    console.error('Load stats error:', e);
                }
            },

            loadLeaderboard: function() {
                const leaderboardHtml = `
                    <div class="leader-item"><span>1. @player1</span><span>ELO: 1500</span></div>
                    <div class="leader-item"><span>2. @player2</span><span>ELO: 1450</span></div>
                    <div class="leader-item"><span>3. @player3</span><span>ELO: 1400</span></div>
                `;
                document.getElementById('leaderboard').innerHTML = leaderboardHtml;
            },

            // GAMES - CRITICAL FIX HERE
            loadGames: async function() {
                const listEl = document.getElementById('gamesList');
                try {
                    if (!this.hubContract) return;
                    const count = await this.hubContract.gameCount();
                    let html = '';
                    
                    for (let i = count.toNumber(); i >= Math.max(1, count.toNumber() - 20); i--) {
                        try {
                            const game = await this.hubContract.games(i);
                            if (game[10]) {  // active
                                const creator = game[4];
                                const player2 = game[5];
                                const isMyGame = creator.toLowerCase() === this.userAddress?.toLowerCase() || player2.toLowerCase() === this.userAddress?.toLowerCase();
                                const zeroAddr = '0x0000000000000000000000000000000000000000';
                                const canJoin = player2.toLowerCase() === zeroAddr.toLowerCase();
                                
                                html += `
                                    <div class="tournament-card">
                                        <div>
                                            <strong>${game[1]} Game #${i}</strong><br>
                                            Stake: ${ethers.utils.formatEther(game[2])} CORE<br>
                                            Creator: ${creator.slice(0,6)}...
                                        </div>
                                        ${isMyGame ? '<span style="color: var(--core-green);">Your Game</span>' : ''}
                                        ${canJoin && !isMyGame ? `<button onclick="window.crossRealmApp.joinGame(${i})">Join</button>` : ''}
                                        <button onclick="window.crossRealmApp.viewGame(${i})">View Board</button>
                                    </div>
                                `;
                            }
                        } catch (e) {
                            console.error('Error loading game:', e);
                        }
                    }
                    listEl.innerHTML = html || '<p>No active games. Create one!</p>';
                } catch (e) {
                    console.error('Load games error:', e);
                }
            },

            // FIX: Renamed to viewGame and simplified
            viewGame: async function(id) {
                console.log('Viewing game:', id);
                this.currentGameId = id;
                try {
                    if (!this.hubContract) {
                        this.showAlert('Not connected', 'error');
                        return;
                    }
                    
                    this.currentGame = await this.hubContract.games(id);
                    console.log('Game data:', this.currentGame);
                    
                    if (!this.currentGame[10]) {
                        this.showAlert('Game is not active', 'error');
                        return;
                    }
                    
                    // Show game board
                    document.getElementById('gameBoard').classList.remove('hidden');
                    
                    const zeroAddr = '0x0000000000000000000000000000000000000000';
                    const opponent = this.currentGame[5].toLowerCase() === zeroAddr.toLowerCase() ? 'Open' : this.currentGame[5].slice(0,6)+"...";
                    const turnText = this.currentGame[13] === 0 ? 'Creator' : 'Player 2';
                    
                    document.getElementById('gameInfo').innerHTML = `
                        <h3>Game #${id}</h3>
                        <p><strong>Type:</strong> ${this.currentGame[1].toUpperCase()}</p>
                        <p><strong>Stake:</strong> ${ethers.utils.formatEther(this.currentGame[2])} CORE</p>
                        <p><strong>Opponent:</strong> ${opponent}</p>
                        <p><strong>Current Turn:</strong> ${turnText}</p>
                    `;
                    
                    this.renderBoard();
                    
                } catch (e) {
                    console.error('View game error:', e);
                    this.showAlert('Error loading game: ' + e.message, 'error');
                }
            },

            // FIX: Simplified board rendering
            renderBoard: function() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                
                if (!this.currentGame) return;
                
                const gameType = this.currentGame[1].toLowerCase();
                const fen = this.currentGame[11];
                
                console.log('Rendering', gameType, 'with FEN:', fen);
                
                if (gameType === 'chess') {
                    this.renderChessBoard(fen);
                } else if (gameType === 'checkers') {
                    this.renderCheckersBoard();
                }
                
                // Add click handlers
                document.querySelectorAll('.square').forEach(sq => {
                    sq.addEventListener('click', (e) => this.handleSquareClick(e));
                });
            },

            renderChessBoard: function(fen) {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                
                try {
                    this.gameChess = new Chess(fen);
                    const board = this.gameChess.board();
                    
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const square = document.createElement('div');
                            const isLight = ((7-row) + col) % 2 === 0;
                            square.className = `square ${isLight ? 'light' : 'dark'}`;
                            square.dataset.row = row;
                            square.dataset.col = col;
                            
                            const piece = board[row][col];
                            if (piece) {
                                const symbol = piece.color === 'w' 
                                    ? this.pieceSymbols[piece.type.toUpperCase()]
                                    : this.pieceSymbols[piece.type.toLowerCase()];
                                square.textContent = symbol || '';
                            }
                            
                            boardEl.appendChild(square);
                        }
                    }
                } catch (e) {
                    console.error('Chess render error:', e);
                    boardEl.innerHTML = '<p>Error rendering board</p>';
                }
            },

            renderCheckersBoard: function() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        const isPlayable = (row + col) % 2 === 0;
                        square.className = `square ${isPlayable ? 'dark' : 'light'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        if (isPlayable) {
                            if (row < 3) {
                                square.textContent = '●';
                                square.style.color = '#000';
                            } else if (row > 4) {
                                square.textContent = '○';
                                square.style.color = '#fff';
                            }
                        }
                        
                        boardEl.appendChild(square);
                    }
                }
            },

            handleSquareClick: function(e) {
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                if (this.selectedSquare) {
                    this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                    this.selectedSquare = null;
                    this.clearHighlights();
                } else {
                    this.selectedSquare = {row, col};
                    e.target.classList.add('selected');
                    this.highlightPossibleMoves(row, col);
                }
            },

            highlightPossibleMoves: function(row, col) {
                if (this.gameChess) {
                    const from = String.fromCharCode(97 + col) + (8 - row);
                    const moves = this.gameChess.moves({square: from, verbose: true});
                    
                    moves.forEach(move => {
                        const toCol = move.to.charCodeAt(0) - 97;
                        const toRow = 8 - parseInt(move.to[1]);
                        const sq = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                        if (sq) sq.classList.add('possible');
                    });
                }
            },

            clearHighlights: function() {
                document.querySelectorAll('.square').forEach(sq => {
                    sq.classList.remove('selected', 'possible');
                });
            },

            makeMove: async function(fromRow, fromCol, toRow, toCol) {
                try {
                    if (!this.hubContract) return;
                    
                    let moveStr = '', newFen = '';
                    
                    if (this.currentGame[1].toLowerCase() === 'chess' && this.gameChess) {
                        const from = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                        const to = String.fromCharCode(97 + toCol) + (8 - toRow);
                        const move = this.gameChess.move({from, to, promotion: 'q'});
                        
                        if (!move) {
                            this.showAlert('Invalid move', 'error');
                            return;
                        }
                        
                        moveStr = move.san;
                        newFen = this.gameChess.fen();
                    } else {
                        moveStr = `${String.fromCharCode(97 + fromCol)}${fromRow + 1}-${String.fromCharCode(97 + toCol)}${toRow + 1}`;
                        newFen = this.currentGame[11];
                    }
                    
                    const proof = '0x';
                    const tx = await this.hubContract.makeMove(this.currentGameId, moveStr, newFen, proof);
                    
                    this.showAlert('Move submitted...', 'info');
                    await tx.wait();
                    this.showAlert('Move executed!', 'success');
                    
                    // Reload game
                    setTimeout(() => this.viewGame(this.currentGameId), 1000);
                    
                } catch (e) {
                    console.error('Make move error:', e);
                    this.showAlert('Move failed: ' + e.message, 'error');
                }
            },

            // CREATE GAME
            setupCreateGame: function() {
                document.getElementById('createGameBtn').onclick = () => this.createGame();
            },

            createGame: async function() {
                try {
                    if (!this.hubContract || !this.userAddress) {
                        this.showAlert('Connect wallet first', 'error');
                        return;
                    }

                    const gameType = document.getElementById('gameType').value;
                    const stakeAmount = document.getElementById('stakeAmount').value;
                    const referral = document.getElementById('referral').value;

                    if (!stakeAmount || parseFloat(stakeAmount) <= 0) {
                        this.showAlert('Enter valid stake amount', 'error');
                        return;
                    }

                    const stake = ethers.utils.parseEther(stakeAmount);
                    const isPrivate = document.getElementById('isPrivate').checked;
                    const isAI = document.getElementById('isAI').checked;
                    const verifier = this.VERIFIER_ADDRESSES[gameType];

                    const tx = await this.hubContract.createGame(
                        gameType,
                        stake,
                        this.CORE_TOKEN,
                        isPrivate,
                        referral || ethers.constants.AddressZero,
                        isAI,
                        false,
                        verifier,
                        { value: stake }
                    );

                    this.showAlert('Creating game...', 'info');
                    const receipt = await tx.wait();
                    
                    this.showAlert('Game created! Tx: ' + receipt.transactionHash.slice(0, 10) + '...', 'success');
                    
                    // Clear form
                    document.getElementById('stakeAmount').value = '';
                    document.getElementById('referral').value = '';
                    
                    // Reload games list
                    setTimeout(() => {
                        this.loadGames();
                        // Auto-switch to games tab
                        document.querySelector('[data-tab="games"]').click();
                    }, 2000);
                    
                } catch (e) {
                    console.error('Create game error:', e);
                    this.showAlert('Failed: ' + (e.reason || e.message), 'error');
                }
            },

            // JOIN GAME
            joinGame: async function(id) {
                try {
                    if (!this.hubContract) return;
                    
                    const game = await this.hubContract.games(id);
                    const tx = await this.hubContract.joinGame(id, { value: game[2] });
                    
                    this.showAlert('Joining game...', 'info');
                    await tx.wait();
                    this.showAlert('Joined! Game ready.', 'success');
                    
                    setTimeout(() => {
                        this.loadGames();
                        this.viewGame(id);
                    }, 1000);
                    
                } catch (e) {
                    console.error('Join error:', e);
                    this.showAlert('Join failed: ' + e.message, 'error');
                }
            },

            // END GAME
            setupGameControls: function() {
                document.getElementById('claimWinBtn').onclick = () => this.claimWin();
                document.getElementById('resignBtn').onclick = () => {
                    if (confirm('Resign and lose this game?')) {
                        this.claimWin(false);
                    }
                };
            },

            claimWin: async function(creatorWins = true) {
                try {
                    if (!this.hubContract) return;
                    
                    const tx = await this.hubContract.endGame(this.currentGameId, creatorWins);
                    this.showAlert('Ending game...', 'info');
                    await tx.wait();
                    this.showAlert('Game ended!', 'success');
                    
                    document.getElementById('gameBoard').classList.add('hidden');
                    this.loadGames();
                    
                } catch (e) {
                    console.error('End game error:', e);
                    this.showAlert('Failed: ' + e.message, 'error');
                }
            },

            // PROFILE
            loadUserStats: async function() {
                if (!this.userAddress) return;
                try {
                    if (!this.rewardsContract) return;
                    
                    const games = await this.rewardsContract.userGamesPlayed(this.userAddress);
                    const wins = await this.rewardsContract.userWins(this.userAddress);
                    const losses = await this.rewardsContract.userLosses(this.userAddress);
                    const elo = await this.rewardsContract.userElo(this.userAddress);
                    
                    this.userStats = {
                        games: games.toNumber(),
                        wins: wins.toNumber(),
                        losses: losses.toNumber(),
                        elo: elo.toNumber()
                    };
                } catch (e) {
                    console.error('Load stats error:', e);
                }
            },

            loadProfile: async function() {
                await this.loadUserStats();
                
                const userStatsEl = document.getElementById('userStats');
                if (userStatsEl) {
                    userStatsEl.innerHTML = `
                        <div class="stats-grid">
                            <div class="stat-card">Games Played<br>${this.userStats.games}</div>
                            <div class="stat-card">Wins<br>${this.userStats.wins}</div>
                            <div class="stat-card">Losses<br>${this.userStats.losses}</div>
                            <div class="stat-card">ELO<br>${this.userStats.elo}</div>
                        </div>
                    `;
                }
                
                const analyticsEl = document.getElementById('userAnalytics');
                if (analyticsEl) {
                    const winRate = this.userStats.games > 0
                        ? ((this.userStats.wins / this.userStats.games) * 100).toFixed(1)
                        : 0;
                    analyticsEl.innerHTML = `
                        <p style="text-align: center; font-size: 18px;">
                            <strong>Win Rate: ${winRate}%</strong>
                        </p>
                    `;
                }
            },

            setupProfileControls: function() {
                document.getElementById('claimRewardsBtn').onclick = () => this.claimRewards();
            },

            claimRewards: async function() {
                try {
                    if (!this.rewardsContract) return;
                    
                    const ts = Math.floor(Date.now() / 1000);
                    const claimable = await this.rewardsContract.getClaimableRewards(this.userAddress, ts, this.CORE_TOKEN);
                    
                    if (claimable.gt(0)) {
                        const tx = await this.rewardsContract.claimRewards(this.userAddress, ts, this.CORE_TOKEN);
                        this.showAlert('Claiming...', 'info');
                        await tx.wait();
                        this.showAlert(`Claimed ${ethers.utils.formatEther(claimable)} CORE!`, 'success');
                    } else {
                        this.showAlert('No rewards available', 'info');
                    }
                } catch (e) {
                    console.error('Claim error:', e);
                    this.showAlert('Claim failed: ' + e.message, 'error');
                }
            },

            // STAKING
            setupStakingControls: function() {
                document.getElementById('stakeBtn').onclick = () => this.stake();
                document.getElementById('withdrawBtn').onclick = () => this.withdraw();
                document.getElementById('claimStakeRewardBtn').onclick = () => this.claimStakeReward();
            },

            stake: async function() {
                const amount = document.getElementById('stakeInput').value;
                try {
                    if (!amount || parseFloat(amount) <= 0) {
                        this.showAlert('Enter valid amount', 'error');
                        return;
                    }
                    if (!this.stakingContract) return;
                    
                    const parsedAmount = ethers.utils.parseEther(amount);
                    const tx = await this.stakingContract.stake(parsedAmount, { value: parsedAmount });
                    
                    this.showAlert('Staking...', 'info');
                    await tx.wait();
                    this.showAlert('Staked!', 'success');
                    document.getElementById('stakeInput').value = '';
                } catch (e) {
                    this.showAlert('Stake failed: ' + e.message, 'error');
                }
            },

            withdraw: async function() {
                const amount = document.getElementById('stakeInput').value;
                try {
                    if (!amount || parseFloat(amount) <= 0) {
                        this.showAlert('Enter valid amount', 'error');
                        return;
                    }
                    if (!this.stakingContract) return;
                    
                    const parsedAmount = ethers.utils.parseEther(amount);
                    const tx = await this.stakingContract.withdraw(parsedAmount);
                    
                    this.showAlert('Withdrawing...', 'info');
                    await tx.wait();
                    this.showAlert('Withdrawn!', 'success');
                    document.getElementById('stakeInput').value = '';
                } catch (e) {
                    this.showAlert('Withdraw failed: ' + e.message, 'error');
                }
            },

            claimStakeReward: async function() {
                try {
                    if (!this.stakingContract) return;
                    
                    const tx = await this.stakingContract.getReward();
                    this.showAlert('Claiming...', 'info');
                    await tx.wait();
                    this.showAlert('Rewards claimed!', 'success');
                } catch (e) {
                    this.showAlert('Claim failed: ' + e.message, 'error');
                }
            },

            // NFTs
            setupNFTControls: function() {
                document.getElementById('equipNftBtn').onclick = () => this.equipNFT();
            },

            equipNFT: async function() {
                try {
                    const tokenId = parseInt(document.getElementById('tokenIdInput').value);
                    const gameType = document.getElementById('equipGameType').value;
                    
                    if (!tokenId || tokenId <= 0) {
                        this.showAlert('Enter valid token ID', 'error');
                        return;
                    }
                    if (!this.nftContract) return;
                    
                    const tx = await this.nftContract.equip(tokenId, gameType);
                    this.showAlert('Equipping...', 'info');
                    await tx.wait();
                    this.showAlert('NFT equipped!', 'success');
                } catch (e) {
                    this.showAlert('Equip failed: ' + e.message, 'error');
                }
            },

            // UTILS
            showAlert: function(msg, type = 'success') {
                const alertEl = document.createElement('div');
                alertEl.className = 'alert';
                alertEl.style.background = type === 'success' ? '#00cc6a' : type === 'error' ? '#ff4444' : '#f7931a';
                alertEl.textContent = msg;
                document.body.appendChild(alertEl);
                setTimeout(() => alertEl.remove(), 4000);
            },

            setupUtilities: function() {
                document.getElementById('shareBtn').onclick = () => this.shareToSocial();
                document.getElementById('toggleThemeBtn').onclick = () => this.toggleTheme();
            },

            toggleTheme: function() {
                document.body.classList.toggle('light-theme');
                const isDark = !document.body.classList.contains('light-theme');
                localStorage.setItem('crossrealm-theme', isDark ? 'dark' : 'light');
                this.showAlert('Theme toggled', 'info');
            },

            loadTheme: function() {
                const theme = localStorage.getItem('crossrealm-theme') || 'dark';
                if (theme === 'light') {
                    document.body.classList.add('light-theme');
                }
            },

            shareToSocial: function() {
                const text = `I'm playing CrossRealm - On-Chain Chess & Checkers on Core! ELO: ${this.userStats.elo}`;
                const url = window.location.origin + window.location.pathname;
                
                if (navigator.share) {
                    navigator.share({
                        title: 'CrossRealm',
                        text: text,
                        url: url
                    }).catch(err => console.log('Share cancelled'));
                } else {
                    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text + ' ' + url)}`;
                    window.open(twitterUrl, '_blank');
                }
            },

            // POLLING
            startPolling: function() {
                if (this.pollInterval) clearInterval(this.pollInterval);
                this.pollInterval = setInterval(() => {
                    if (this.currentGameId) {
                        this.viewGame(this.currentGameId).catch(() => {});
                    }
                }, 15000); // Every 15 seconds
            },

            stopPolling: function() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
            },

            // INIT
            init: function() {
                this.loadTheme();
                this.setupWalletListeners();
                this.setupTabs();
                this.setupCreateGame();
                this.setupGameControls();
                this.setupStakingControls();
                this.setupNFTControls();
                this.setupProfileControls();
                this.setupUtilities();
                
                this.loadGlobalStats();
                this.loadLeaderboard();
                this.updateWalletStatus();
            }
        };

        // STARTUP
        document.addEventListener('DOMContentLoaded', () => {
            window.crossRealmApp.init();
        });
    </script>
</body>
</html>
